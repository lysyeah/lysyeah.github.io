{"pages":[],"posts":[{"title":"Python 기초문법","text":"Hello world 1print(&quot;Hello world&quot;) Hello world 주석처리 1줄 주석, 여러줄 주석 처리 여러 줄 주석 처리 함수 또는 클래스를 문서화 할 때 주로 사용 프로젝트 할 때 전체 공정 100 코드 / 코드 문서화 / 한글 작업 문서화 코드 문서화가 가장 어렵다. 12345678910# print() 함수 사용print(&quot;1줄 주석&quot;)&quot;&quot;&quot;여러 줄 주석쌍따옴표 3개를 입력해주세요앞과 뒤로 &quot;&quot;&quot;print(&quot;여러 줄 주석&quot;) 1줄 주석 여러 줄 주석 변수 (Scalar) 자료형 Scalar형 Non-Scalar형 수치형 자료형 int, float 1234num_int = 1print(num_int)print(type(num_int)) 1 &lt;class 'int'&gt; 123num_float = 0.1print(num_float)print(type(num_float)) 0.1 &lt;class 'float'&gt; Bool형 True, False R에선 모든 대문자: TRUE, FALSE 123bool_true = Trueprint(bool_true)print(type(bool_true)) True &lt;class 'bool'&gt; None 자료 Null값, 값이 정해지지 않은 자료형 123none_x = Noneprint(none_x)print(type(none_x)) None &lt;class 'NoneType'&gt; 사칙연산 정수형 사칙연산, 실수형 사칙연상 결괏값의 자료형 정수형 사칙연산123a = 3b = 2print('a + b =', a+b) a + b = 5 실수형 사칙연산123a = 1.5b = 2.5print('a + b = ', a+b) a + b = 4.0 123456a = 3.3b = 6.4print('a + b = ', a+b )print('a - b = ', a-b )print('a*b = ', a*b)print('a/b=', a/b) a + b = 9.7 a - b = -3.1000000000000005 a*b = 21.12 a/b= 0.5156249999999999 논리형 연산자 Bool형 True와 False값으로 정의 조건식 교집합(=and), 합집합(=or) 1234print(True and True)print(True and False)print(False and True)print(False and False) True False False False 1234print(True or True)print(True or False)print(False or True)print(False or False) True True True False 비교 연산자 비교 연산자는 부등호를 의미한다. 12345print(4&gt;3) #참 = Trueprint(4&lt;3) #거짓 = Falseprint(4&gt;3 and 4&lt;3)print(4&gt;3 or 4&lt;3) True False False True 논리형 &amp; 비교 연산자 응용 input() 형변환 데이터 타입을 변경하는 것 123var = int(input(&quot;숫자를 입력하세요..!&quot;))print(var)print(type(var)) 숫자를 입력하세요..!1 1 &lt;class 'int'&gt; 1234num1 = int(input(&quot;첫번째 숫자를 입력하세요..!&quot;))num2 = int(input(&quot;두번째 숫자를 입력하세요..!&quot;))num3 = int(input(&quot;세번째 숫자를 입력하세요..!&quot;))num4 = int(input(&quot;네번째 숫자를 입력하세요..!&quot;)) 첫번째 숫자를 입력하세요..!1 두번째 숫자를 입력하세요..!2 세번째 숫자를 입력하세요..!3 네번째 숫자를 입력하세요..!4 12var1 = num1 &gt;= num2 #Falsevar2 = num3 &lt; num4 #True 12print(var1 and var2)print(var1 or var2) False True String Non-Scalar 123456print('Hello world')print(&quot;Hello world&quot;)print(&quot;'Hello world'&quot;)print('&quot;Hello world&quot;') Hello world Hello world 'Hello world' &quot;Hello world&quot; String Operator 문자열 연산자 +, * 만 가능하다. 123str1 = &quot;Hello &quot;str2 = &quot;World &quot;print(str1 + str2) Hello World 12greet = str1 + str2print(greet *8) Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World 12a = &quot;Pyhone&quot;a 'Pyhone' 조건문 if123a = 3if a &gt; 1: print (&quot;a is greater than 1&quot;) #if a &gt; 1: 다음 문장은 Tab으로 들여쓰기를 해야한다. a is greater than 1 반복문 for123a = &quot;Pthon&quot;for a in [1,2,4]: print(a) 1 2 4 반복문 while1234i = 0while i &lt; 3: i = i++1 print(i) 1 2 3 함수1234def add(a, b): return a+b add(3,4) 7 ##8진수와 16진수 #진수는잘쓰이진 않음 123a = 0o177 #8진수b = 0xABCprint(a,b) 127 2748 사칙연산123a = 3b = 4a ** b 81 나눗셈 후 나머지를 반환하는 % 연산자17 % 3 1 13%7 3 나눗셈 후 몫을 반환하는 //연산자 17 //4 1 문자열에 작은 따옴표 (‘’)포함시키기 12food = &quot;Pyhon's favorite food is perl&quot; #''로 하면 오류가 발생한다.food &quot;Pyhon's favorite food is perl&quot; 1 문자열 인덱싱 인덱싱은 0 번째부터 시작 12345greeting = &quot;Hello Kaggle&quot;i = 7print(greeting[i]) # 이렇게 하는 것이 빈번하다. 제대로 된 것인지 확인할 때 쓴다print(greeting)print(greeting[4]) a Hello Kaggle o 123greeting = &quot;Hello Kaggle&quot;i = int(input(&quot;숫자를 입력하세요...!&quot;))print(greeting[i]) 숫자를 입력하세요...!2 l ##슬라이싱 123456789greeting = &quot;Hello Kaggle&quot;# print(greeting[시작인덱스:끝인덱스-1])print(greeting[0:8])print(greeting[:8])print(greeting[6:])print(greeting[0:10:2])print(greeting[0:10:3])print(greeting[0:10:4]) Hello Ka Hello Ka Kaggle HloKg HlKg Hog 12alphabet_letter = &quot;abcdefghijklmnopqrstuvwxyz &quot;print(alphabet_letter[0::2]) acegikmoqsuwy 12greeting = &quot;Hello Kaggle&quot;print(greeting[100]) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-104-128f57967a72&gt; in &lt;module&gt;() 1 greeting = &quot;Hello Kaggle&quot; ----&gt; 2 print(greeting[100]) IndexError: string index out of range 12greeting = &quot;Hello Kaggle&quot;print(greeting[11]) e 문자열 관련 메소드 split() srt() etc 리스트 []로 표시. [item1, item2, item3] 123456a = [] # 빈 리스트a = function = list # 빈 리스트 생성b = [1] # 숫자 요소c = ['apple'] # 문자 요소d = [1, 2, ['aplpe'],'apple']print(d) [1, 2, ['aplpe'], 'apple'] 리스트 값 수정하기 리스트 값 수정 123a = [0,1,2]a[1] = &quot;이용수&quot;print(a) [0, '이용수', 2] 리스트 값 추가하기 메소드 사용 123456a = [100,200,300]a.append(400) #a = a.append(400) 이렇게 하지 않고 바로 a.append로 한다. print(a)a.append([500,600])print(a) [100, 200, 300, 400] [100, 200, 300, 400, [500, 600]] 1234567a = [100,200,300]a.append(400) #하나의 값만 넣고 싶을 때print(a)a.extend([400,500]) # 여러 값을 넣고 싶을 때print(a) [100, 200, 300, 400] [100, 200, 300, 400, 400, 500] insert(인덱스 특정 위치에 값을 넣기)123a = [100,200,300]a.insert(0,50)print(a) [50, 100, 200, 300] 리스트 값 삭제하기 remove, del 123456a = [1,2,1,2]a.remove(1)print(a) # 첫번째 등장하는 1을 삭제한다a.remove(10) [2, 1, 2] --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-118-90e7fa84a5d0&gt; in &lt;module&gt;() 4 print(a) # 첫번째 등장하는 1을 삭제한다 5 ----&gt; 6 a.remove(10) ValueError: list.remove(x): x not in list 1234567a = [1,2,1,2,10]a.remove(1)print(a) # 첫번째 등장하는 1을 삭제한다a.remove(10)print(a) [2, 1, 2, 10] [2, 1, 2] +del 123456a = [0,1,2,3,4]del a[1]print(a)del a[:2]print(a) [0, 2, 3, 4] [3, 4] 문자열, 리스트 내장함수를 익히는 것이 포인트!! pop() 12345678a = [1,2,3,4,5]rem = a.pop(1)x = a.pop() # 마지막값 출력print(a)print(rem)print(x) [1, 3, 4] 2 5 clear() : 리스트 내 모든 값 삭제 index(“값”) : 값의 위치를 불러오기(찾기) 1234a = [1,4,5,2,3]b = [&quot;철수&quot;, &quot;영희&quot;, &quot;길동&quot;]print(a.index(4))print(b.index(&quot;길동&quot;)) 1 2 sort : 리스트의 정렬 1234567a = [1,4,5,2,3]a.sort()print(a)a.sort(reverse=True)print(a)help(list.sort)help(list.index) [1, 2, 3, 4, 5] [5, 4, 3, 2, 1] Help on method_descriptor: sort(self, /, *, key=None, reverse=False) Stable sort *IN PLACE*. Help on method_descriptor: index(self, value, start=0, stop=9223372036854775807, /) Return first index of value. Raises ValueError if the value is not present. 튜플 면접 질문 : 리스트와 튜플의 차이는 무엇인가? list : [] 수정, 삭제, 추가 튜플 : () 다 안됨 12345678910tuple1 = (0)tuple2 = (0, )tuple3 = 0, 1, 2print(type(tuple1))print(type(tuple2))print(type(tuple3)) #콤마가 있으냐 없느냐에 따라서 인트인지 튜플인지 구분된다.print(tuple1) # 그냥 숫자가 프린트된다.print(tuple2)print(tuple3) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 0 (0,) (0, 1, 2) 12a = (0,1,2,3,&quot;a&quot;)del a [4] --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-146-dbd44eb80870&gt; in &lt;module&gt;() 1 a = (0,1,2,3,&quot;a&quot;) ----&gt; 2 del a [4] TypeError: 'tuple' object doesn't support item deletion 123a = [0,1,2,3,&quot;a&quot;] #()로 하면 에러뜬다.a[4] = 4print(a) [0, 1, 2, 3, 4] 튜플(리스트도 포함) 연산자 문자열 연산자 +, * 1234t1 = [0,1,2] # []로 하든 ()로 하든 동일한 결과값이 나온다.t2 = [3,4,5]print(t1+t2)print(t1*t2) [0, 1, 2, 3, 4, 5] --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-150-2bab607964b9&gt; in &lt;module&gt;() 2 t2 = [3,4,5] 3 print(t1+t2) ----&gt; 4 print(t1*t2) TypeError: can't multiply sequence by non-int of type 'list' dictionary keys와 value로 구성됨 cf) 슬라이싱 : 데이터에 순서가 존재해야한다.. 순서라는 개념 자체가 존재하지 않음 123456789101112temp_dict = { 'teacher' : 'evan', 'class' : 15, 'students' : ['s1', 's2', 's3']}print(temp_dict[&quot;teacher&quot;])print(temp_dict[&quot;class&quot;])print(temp_dict[&quot;students&quot;])print(temp_dict[&quot;A&quot;]) evan 15 ['s1', 's2', 's3'] --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-165-8ddb924c1f32&gt; in &lt;module&gt;() 9 print(temp_dict[&quot;class&quot;]) 10 print(temp_dict[&quot;students&quot;]) ---&gt; 11 print(temp_dict[&quot;A&quot;]) KeyError: 'A' keys()값만 출력 12list(temp_dict.keys()) ['teacher', 'class', 'students'] value() 값만 출력 1temp_dict.values() dict_values(['evan', 15, ['s1', 's2', 's3']]) item() key-values 쌍으로, list와 tuple 형태로 변환 가능하다. 1temp_dict.items() dict_items([('teacher', 'evan'), ('class', 15), ('students', ['s1', 's2', 's3'])]) 조건문 12345678910a = -5if a &gt; 5: print(&quot;a는 5보다 크다&quot;)elif a &gt; 0: print(&quot;a는 0보다 크다 &quot;)elif a &gt; -5: print(&quot;a는 -5보다 크다&quot;)else: print(&quot;a는 매우 작다&quot;) # 조건문이 만족하는 것만 출력된다. a는 매우 작다 반복문1234### Hello world 1,000,000번 출력하세요for i in range(7): # 여기서 i는 그냥 변수 print(i+1) print(&quot;Hello world&quot;) 1 Hello world 2 Hello world 3 Hello world 4 Hello world 5 Hello world 6 Hello world 7 Hello world 123### Hello world 1,000,000번 출력하세요for i in range(5): # 여기서 i는 그냥 변수. 아무거나 넣어도 됌 print(i+1,&quot;Hello world&quot;) 1 Hello world 2 Hello world 3 Hello world 4 Hello world 5 Hello world for loop if 조건문 사용 문자열 리스트 등 –&gt; 시퀀스 데이터 123456a = &quot;Kaggle&quot;# g 가 시작하면 반복문을 멈추세요for x in a: print(x) if x == 'g': break K a g 12345678a = &quot;Kaggle&quot;# g 가 시작하면 반복문을 멈추세요for x in a: if x == 'g': break print(x) # print(x) 의 위치에 따라 결과값이 달라지네?? K a enumerate() 1234alphabets = ['a', 'b', 'c']for i, value in enumerate(alphabets): print(i, value) 0 a 1 b 2 c 리스 컴프리헨션list comprehension #반복문을 한줄로 표시한다 12345678fruits = ['apple', 'kiwi', 'mango']newlists = []# 알파벳 a가 있는 과일만 추출 후, 새로운 리스트에 담기for fruit in fruits: if &quot;a&quot; in fruit: newlists.append(fruit)print(newlists) # 너무 복잡하네... ['apple', 'mango'] 123# 리스트 컴프리헨션newlist = [fruit for fruit in fruits if 'a' in fruit] print(newlist) ['apple', 'mango'] 줄을 바꾸기 위한 이스케이프 코드 \\n 삽입하기 12multiline = &quot;Life is too short \\nYou need python &quot;print(multiline) Life is too short You need python 12345multiline=&quot;&quot;&quot;Life is too shortYou need python&quot;&quot;&quot;print(multiline) Life is too short You need python \\n : 문자열 안에서 줄을 바꿀 때 사용\\t : 문자열 사이에 탭 간격을 줄 때 사용\\ : 문자\\를 그대로 표현할 때 사용' : 작음따옴표(‘)를 그대로 표현할 때 사용&quot; : 큰따옴표(“)를 그대로 표현할 때 사용 12a = &quot;abcde\\nfg&quot;print(a) abcde fg 12a = &quot;abcd\\fefg&quot;print(a) abcd efg 12a = &quot;abcdef\\'g\\'&quot;print(a) abcdef'g' 12a = &quot;abcdef\\&quot;g\\&quot;&quot;print(a) abcdef&quot;g&quot; 123head = &quot;Python&quot;tail = &quot;is fun&quot;head + tail 'Pythonis fun' 12a = &quot;fun&quot;a*2 'funfun' 문자열 곱하기를 좀 더 응용해 보자. 다음 소스를 IDLE 에디터를 열고 작성해 보자. multistring.pyprint(“=” * 50)print(“My Program”)print(“=” * 50)입력한 소스는 C:\\doit 디렉터리에 파일 이름 multistring.py로 저장하자. 이제 프로그램을 실행해 보자. [윈도우 + R(실행) → cmd 입력 → Enter]를 눌러 명령 프롬프트 창을 열고 다음을 따라 해 보자. 결괏값이 다음과 같이 나타날 것이다. C:\\Users&gt;cd C:\\doitC:\\doit&gt;python multistring.py==================================================My Program==================================================이런 식의 표현은 앞으로 자주 사용하게 될 것이다. 프로그램을 만들어 실행시켰을 때 출력되는 화면 제일 위쪽에 프로그램 제목을 이와 같이 표시하면 보기 좋지 않겠는가? 12a = &quot;0123456789101112&quot;len(a) 16 12a = &quot;12345678910&quot;a[9:11] # 인덱스가 되어있기 때문에 10을 표현하려면 슬라이싱으로 표현해야한다. '10'","link":"/2022/06/27/day0627/"},{"title":"반복문 복습","text":"for loop and while loop123for i in range(3): #i는 임의의 변수 print(&quot;hello&quot;) print(&quot;안녕하세요&quot;) hello 안녕하세요 hello 안녕하세요 hello 안녕하세요 123456for i in range(1000): print(&quot;No : &quot;,i+1) #i는 임의의 변수 if i == 10: #1000번이 너무 많으니 중간에 break 걸어보자 break print(&quot;hello&quot;) print(&quot;안녕하세요&quot;) No : 1 hello 안녕하세요 No : 2 hello 안녕하세요 No : 3 hello 안녕하세요 No : 4 hello 안녕하세요 No : 5 hello 안녕하세요 No : 6 hello 안녕하세요 No : 7 hello 안녕하세요 No : 8 hello 안녕하세요 No : 9 hello 안녕하세요 No : 10 hello 안녕하세요 No : 11 12345&quot;K&quot; in &quot;Kaggle&quot;if &quot;K&quot; == &quot;a&quot;: print(&quot;출력이 되나요?&quot;)else: print(&quot;출력이 안된듯&quot;) 출력이 안된듯 123456a = &quot;Kaggle&quot;for i in a: print(i) if i == &quot;a&quot;: break K a 리스트의 값이 존재 전체 총합 구함 12345678910numbers = [1,2,3,4,5]sum = 0for num in numbers: print(&quot;numbers:&quot; , num) sum = sum + num print(&quot;total: &quot;, sum)print(&quot;---최종 결과값---&quot;)print(sum) numbers: 1 total: 1 numbers: 2 total: 3 numbers: 3 total: 6 numbers: 4 total: 10 numbers: 5 total: 15 ---최종 결과값--- 15 12345678910111213fruits = ['apple', 'kiwi', 'mango']newlist = [ ]# apple 에 a가 있나요? 있네요. newlist에 추가하세요.# kiwi 에 a가 있나요? 없네요. 그럼 넘어가요.# mango 에 a가 있나요? 있네요. newlist에 추가하세요.for fruit in fruits: print(&quot;조건문 밖 : &quot;, fruit) if &quot;a&quot; in fruit: print(&quot;조건문 안 :&quot;, fruit) ##중간중간에 print 해서 잘되고 있나 확인하기. newlist. append(fruit)print(newlist) 조건문 밖 : apple 조건문 안 : apple 조건문 밖 : kiwi 조건문 밖 : mango 조건문 안 : mango ['apple', 'mango'] while loop : 분석할 때 쓸 일이 거의 없다. 자동사냥처럼 범위가 정해지지 않은 경우 while을 주로 쓴다. 자동사냥 버튼을 끌 때까지 계속 해라. 123456i = 1while i &lt; 10: #참일때만 반복문 코드가 돎 print(i) i += 1 # 1씩 증가#i -=1 # 1씩 감소 1 2 3 4 5 6 7 8 9 사용자 정의 함수 내가 필요에 의해 직접 함수를 작성 123def 함수명(param1, param2): #코드 return None 12345def add(a = 0 , b = 1): c = a + b return c # = return a+bprint(add(a=5, b=4))print(add()) 9 1 사칙 연산 사용자 정의 함수 만들기 함수 문서화 키워드 : docstring #좋은 회사일수록 문서화를 중요시한다. 1234567891011121314151617def subtraction(a,b): &quot;&quot;&quot; a, b를 빼는 함수 parameters: a(int) : int형 숫자 a가 입력 b(int) : int형 숫자 b가 입력 return: int : 반환값&quot;&quot;&quot; return a-bprint(subtraction(a=5, b=2))#### 중요하다. #### #### 좋은 회사 가려면 문서화 꼭 하자. 1000명 중 한 두명 한다. #### 3 12345def Multiplication(a=0, b=1): c = a * b return cprint(Multiplication(a=2,b=3))print(Multiplication()) 6 0 12345def main(a=5, b=3): c = a-b return cprint(main(a=8,b=2))print(main()) 6 2 12345def Liberty(a=2, b=8): c = b/a return cprint(Liberty(a=2,b=10))print(Liberty()) 5.0 4.0 123def subtraction(a,b): return a**bprint(subtraction(a=10,b=3)) 1000 12345678910111213141516def remain(a,b,c): return a%b+cprint(remain(a=19,b=4,c=6)) &quot;&quot;&quot; a 나누기 b 의 나머지에 c를 더하는 함수 parameters: a(int) : int형 숫자 a가 입력 b(int) : int형 숫자 b가 입력 c(int) : int형 숫자 c가 입력 return: int : 반환값&quot;&quot;&quot; 9 NumPy 문법 소개 내장 모듈 (= 라이브러리 = 패키지) # 파이썬에서 라이브러리라고 주로 표현 한다(X) 별도 라이브러리 설치 필요함. 12import numpy as np #버전 확인하기print(np.__version__) 1.21.6 12import numpyprint(numpy.__version__) 1.21.6 12345temp = [1,2,3]temp_array = np.array(temp) #리스트에서 배열로 변환하기.print(type(temp))print(type(temp_array)) &lt;class 'list'&gt; &lt;class 'numpy.ndarray'&gt; 사칙연산1# 코드로 형식 지정됨 12345678910111213math_score = [90, 80,70]eng_score = [100,50,80]math_score + eng_scoremath_score = np.array(math_score)eng_score = np.array(eng_score)total = math_score + eng_scoreprint(total)print(type(total)) [190 130 150] &lt;class 'numpy.ndarray'&gt; 집계함수 123print(np.min(total))print(np.max(total))print(np.sum(total)) 130 190 470 차원 확인 배열 차원 확인이 필요함 1234# 1차원 배열temp_arr = np.array([1,2,3])print(temp_arr.shape)print(temp_arr.ndim) (3,) 1 12345# 2차원 배열temp_arr = np.array([[1,2,3],[4,5,6]])print(temp_arr.shape)print(temp_arr.ndim)print(temp_arr) (2, 3) 2 [[1 2 3] [4 5 6]] 123456789# 3차원 배열 = 이미지 파일temp_arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])print(temp_arr.shape)print(temp_arr.ndim)print(temp_arr)#[[1, 2, 3], [4, 5, 6]]= 하나 // [[7, 8, 9], [10, 11, 12]]= 둘 첫번째 숫자#[1, 2, 3]=하나, [4, 5, 6]=둘 # 첫번째 숫자 안에 있는 []의 갯수#[1, 2, 3] =셋 안에 있는 숫자 갯수 (2, 2, 3) 3 [[[ 1 2 3] [ 4 5 6]] [[ 7 8 9] [10 11 12]]] 파이썬 인터프리터 종류 파이썬 버전이 매우 많음 웹 개발 : 파이썬 3.7버전 머신 러닝 : 파이썬 3.8버전 GUI : 파이썬 3.9 버전 버전에 따라서 패키지를 다운로드를 더할 필요가 있다. 아나콘다에서는 numpy가 1.21.0 버전 파이썬 virtualenv에서는 numpy가 1.23.0 버전##이로써 Which python으로 현재 내 파이썬이 참조하는 경로찾기.##파이썬으로 venv를 만들고 접속하기 = source venv/scripts/activate which python 경로가 어디지? python temp.pysource venv/scripts/activate 이거 할 때 탭 눌러서 완성하기. which python 설정했으니 확인해보자. deactivatewhich python배열 생성의 다양한 방법들 모두 0으로 채운다. 12import numpy as npprint(np.__version__) 1.21.6 12temp_arr = np.zeros((3, 2, 3)) ###숫자 바꾸면서 어떻게 달라지는지 보기temp_arr array([[[0., 0., 0.], [0., 0., 0.]], [[0., 0., 0.], [0., 0., 0.]], [[0., 0., 0.], [0., 0., 0.]]]) 12temp_arr = np.ones((2,3))temp_arr array([[1., 1., 1.], [1., 1., 1.]]) 임의의 상수값으로 채운다. 12temp_arr = np.full((3,3),5) ###이렇게 하는 방법도 있다.temp_arr array([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) 최소, 최대 숫자의 범위를 정하고, 각 구간 별로 값을 생성한다. 12temp_arr = np.linspace(5, 10, 10) #5와 10사이의 숫자를 10개 값 생성temp_arr array([ 5. , 5.55555556, 6.11111111, 6.66666667, 7.22222222, 7.77777778, 8.33333333, 8.88888889, 9.44444444, 10. ]) 반복문 시, 자주 등장하는 배 12temp_arr = np. arange(1, 11, 1) ## 1부터 11미만까지 1커지는 숫자로 나열하기. ##아 이런 methods들이 있구나 하고 넘어가기.temp_arr array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 난수 생성하기. 1234from numpy import random ##코딩도장에서 패키지 만들기에 있다. from square import 머시기 있음.x = random.rand()print(x) 0.2234016171962998 123import numpyx = numpy.random.rand()print(x) ##바로 뒤에 있는 것과 같은 것이다. 0.5932025329031522 랜덤 정수값 추출 12345from numpy import random# x= random.randint(100, size = 5)x = random.randint(100, size = (3,5)) #두가지방법 둘다 복습해보기.print(x)print(type(x)) [[20 97 7 19 67] [72 25 9 32 43] [57 47 53 65 41]] &lt;class 'numpy.ndarray'&gt; 1234from numpy import randomx = random.rand(2,5)print(x)print(type(x)) [[0.16366456 0.48662476 0.47091867 0.1707638 0.43509512] [0.23800188 0.66701242 0.17376954 0.04608532 0.12255199]] &lt;class 'numpy.ndarray'&gt; numpy 사칙연123import numpy as uparray_01 = np.array([1,2,3])array_02 = np.array([10,20,30]) 123456789101112131415161718192021# 덧셈newArr = np.add(array_01, array_02)print(newArr)# 빼기newArr = np.subtract(array_01, array_02)print(newArr)# 곱하기newArr = np.multiply(array_01, array_02)print(newArr)# 나누기newArr = np.divide(array_01, array_02)print(newArr)# 거듭제곱array_01 = np.array([1,2,3])array_02 = np.array([2,4,3])newArr = np.power(array_01,array_02)print(newArr) [3 6 6] [-1 -2 0] [2 8 9] [0.5 0.5 1. ] [ 1 16 27] 소숫점 정령 소숫점을 정렬하는 여러가지 방법 1234567# 소숫점 제거하기import numpy as nptemp_arr = np.trunc([-1.23, 1.23])print(temp_arr)temp_arr = np.fix([-1.23,1.23])print(temp_arr) [-1. 1.] [-1. 1.] 123# 임의의 소숫점 자리에서 반올림temp_arr = np.around([-1.535433, 1.24333],3)print(temp_arr) [-1.535 1.243] 123# 소숫점 모두 내리기temp_arr = np.floor([-1.535433, 1.24333])print(temp_arr) [-2. 1.] 123# 소숫점 모두 올리기temp_arr = np.ceil([-1.535433, 1.24333])print(temp_arr) [-1. 2.] 조건식 pandas 가공 numpy 조건식 하나의 조건식 다중 조건식 12temp_arr = np.arange(10)temp_arr array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1234# 5보다 작으면 원값을 유지한다.# 5보다 크면 곱하기 10을 한다.#np.where(조건식, 참일때, 거짓일때)np.where(temp_arr &lt;= 5, temp_arr, temp_arr * 10) array([ 0, 1, 2, 3, 4, 5, 60, 70, 80, 90]) 123456789temp_arr = np.arange(10)# temp_arrcond_list = [temp_arr &gt;5, temp_arr&lt;2] # cond : condition(=조건)choice_list = [temp_arr*2, temp_arr +100] # np.select(조건식 리스트, 결과값 리스트, default = 값)np.select(cond_list, choice_list, default = temp_arr)#### 정말 많이 쓰는 함수이다. 잘 알아 놓자 ####### np.where 과 np.select 차이점 구글링 해보기. ### array([100, 101, 2, 3, 4, 5, 12, 14, 16, 18]) reshape 배열의 차원 또는 크기를 바꾼다. 전제조건 : 곱셈만 할줄 알면 적용하기 쉽다. 1234import numpy as nptemp_array = np.ones((3,4))print(temp_array.shape)print(temp_array) (3, 4) [[1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.]] 123after_reshape = temp_array.reshape(2,2,3) #괄호 안에 숫자를 모두 곱했을 때 12가 되어야 에러가 뜨지 않는다.print(after_reshape.shape)print(after_reshape) (2, 2, 3) [[[1. 1. 1.] [1. 1. 1.]] [[1. 1. 1.] [1. 1. 1.]]] 123after_reshape = temp_array.reshape(2,2, -1) # 2 곱하기 2 후에 숫자 하나를 더 곱해야 하는데 몇을 곱할지 모를 때 print(after_reshape.shape) # -1을 입력하면 알아서 결과값을 찾아서 넣는다.print(after_reshape) (2, 2, 3) [[[1. 1. 1.] [1. 1. 1.]] [[1. 1. 1.] [1. 1. 1.]]] 브로드 캐스팅 array broadcasting in numpy 정의 및 어떤 기능인지만 알자. 깊게 알려면 배울게 너무 많아서 너무 오래 걸릴 수 있다. 강사님이 올려주신 파일 중에, 다운로드하라고 했던 파일 안에 PDF 안에 있음. Pandas Tutorial12import pandas as pdprint(pd.__version__) 1.3.5 12345678910temp_dict = { 'col1' : [1,2], 'col2' : [3,4]}df = pd.DataFrame(temp_dict)print(df)print(type(df))## 프로그래밍은 테스트를 꼭하고 잘 작동하면 올리기. col1 col2 0 1 3 1 2 4 &lt;class 'pandas.core.frame.DataFrame'&gt; 구글 드라이브 연동12from google.colab import drivedrive.mount('/content/drive') Mounted at /content/drive 12345DATA_PATH = '/content/drive/MyDrive/Colab Notebooks/Human_AI/Basic/Chapter 3. pandas/data'print(DATA_PATH + 'Lemonade2016.csv')#lemonade = pd.read_csv(DATA_PATH + 'Lemonade2016.csv')#covid_df = pd.read_csv(DATA_PATH + 'owid-covid-data') /content/drive/MyDrive/Colab Notebooks/Human_AI/Basic/Chapter 3. pandas/dataLemonade2016.csv 123#경로 문제.#86번에서 1번에서 3. pandas/data 다음에 /을 해줘야 #hapter 3. pandas/data/Lemonade2016.csv 로 나온다. 1234567DATA_PATH = '/content/drive/MyDrive/Colab Notebooks/Human_AI/Basic/Chapter 3. pandas/data/'print(DATA_PATH + 'Lemonade2016.csv')lemonade = pd.read_csv(DATA_PATH + 'Lemonade2016.csv')#covid_df = pd.read_csv(DATA_PATH + 'owid-covid-data')lemonade.info() #str() 이랑 같은 함수이다. /content/drive/MyDrive/Colab Notebooks/Human_AI/Basic/Chapter 3. pandas/data/Lemonade2016.csv &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 32 entries, 0 to 31 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Date 31 non-null object 1 Location 32 non-null object 2 Lemon 32 non-null int64 3 Orange 32 non-null int64 4 Temperature 32 non-null int64 5 Leaflets 31 non-null float64 6 Price 32 non-null float64 dtypes: float64(2), int64(3), object(2) memory usage: 1.9+ KB","link":"/2022/06/28/day0628/"},{"title":"Hello,world 출력 함수 만들기","text":"12345678910111213def hello(): &quot;&quot;&quot; 파이썬 코드는위에서 아래로 순차적으로 실행되기 때문에함수를 먼저 정의하고 난 뒤에함수를 호출 해야한다.&quot;&quot;&quot; print('hello,world')hello()## 독스트링 위치 잘 보자.## 콜론 다음에 적으니까 결과값에 글이 적히지 않는다.## 가장 밑에 적으니 결과값에 나와서 보기 불편하다.## '''보다 &quot;&quot;&quot;를 권장한다고 한다. hello,world 29.2 덧셈 함수 만들기12345def add(a,b): print( a + b )add( 3, 4 ) 7 29.3 함수의 결과를 반환하기 123456def add(a,b):&quot;&quot;&quot; return a+bx = add(10,20)x 30 1234567891011121314151617def not_ten(a): &quot;&quot;&quot; not_ten 함수에 5를 넣으면 5가 출력된다.하지만 10을 넣으면 if가 만족되므로return이 되는것이고출력이 되지 않는다.즉, 밑 함수로 내려가지않는다.&quot;&quot;&quot; if a == 10: return print(a, '입니다', sep='')not_ten(5)not_ten(10)##물결 밑줄 왜 생겼을까?? 5입니다 ##29.4 함수에서 값을 여러 개 반환하기 12345678910def add_sub(a,b): &quot;&quot;&quot;아직 이해가 잘 되지 않는다. 계속 쓰다보면 익숙해지겠지 &quot;&quot;&quot; return a+b, a-bx, y = add_sub(10,20)print(x)print(y) 30 -10 참고 : 값 여러 개를 직접 반환하 123456def one_two(): return[1,2]x, y = one_two()print(x,y) 1 2 ##29.5 함수의 호출 과정 알아보기 1234567891011121314151617def multi(a,b): &quot;&quot;&quot;a쌓고 b쌓고 c쌓는건 알겠는데c를 꺼내고 b를 꺼내고 a를 꺼내는게 왜이런지이해되지가 않는다.&quot;&quot;&quot; c = a*b returndef add(a,b): c = a + b print(c) d = mul(a,b) print(d)x = 10y = 20add(x,y) #29.3 연습문제 : 몫과 나머지를 구하는 함수 만들 12345678def divide(a,b): &quot;&quot;&quot; 슬래시 한번하면 값 그대로 나오고 슬래시 두번하면 몫만 나오면% 나머지값이 나온다&quot;&quot;&quot; return a/b, a//b, a%bdivide(10,3) File &quot;&lt;ipython-input-53-b3eb5ddc7290&gt;&quot;, line 6 return a/b, a//b, a%b ^ IndentationError: unindent does not match any outer indentation level 30.1 위치 인수와 리스트 언패킹 사용하기12print(10,20,30) 10 20 30 30.1.1 위치 인수를 사용하는 함수를 만들고 호출하기 1234567def print_numbers(a,b,c): print(a) print(b) print(c)print_numbers(10,20,30) 10 20 30 30.1.2 언패킹 사용하기 12345x = [10,20,30]print_numbers(*x)## *x를 하면 리스트의 포장을 푼다는 함수가 된다 (=unpacking)## print(numbers(*x)) = print_numbers(10,20,30)라는 말이다. 10 20 30 123print_numbers(*[10,20,30]) # 이렇게도 된다.# 단, 이때 함수의 매개변수 개수와 리스트의 요소 개수는 같아야 한다. 10 20 30 12print_numbers(*[10,20]) # 단, 이때 함수의 매개변수 개수와 리스트의 요소 개수는 같아야한다. --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-67-c2b892dd2c14&gt; in &lt;module&gt;() ----&gt; 1 print_numbers(*[10,20]) TypeError: print_numbers() missing 1 required positional argument: 'c' 30.1.3 가변 인수 함수 만들 12345678def print_numbers(*args): #ars = arguments = 매개변수 for arg in args: print(arg)print_numbers(1,2)print_numbers(10,20,30,40) 1 2 10 20 30 40 12345x = [10]print_numbers(*x)y = [10,20,30,40]print_numbers(*y) 10 10 20 30 40 참고 : 고정 인수와 가변 인수를 함께 사용하기 1234567def print_numbers(a,*args): print(a) print(args)print_numbers(1)print_numbers(1,10,20)print_numbers(*[10,20,30]) 1 () 1 (10, 20) 10 (20, 30) 30.2 키워드 인수 사용하기1234567def personal_info(name, age, address): print('이름: ', name) print('나이:', age) print('주소:', address)personal_info('홍길동', 30, '서울시 용산구 이촌동')#인수의 순서과 용도를 모두기억해야 해서 불편하다. 다음과 같이 해보자 이름: 홍길동 나이: 30 주소: 서울시 용산구 이촌동 1personal_info(name=&quot;홍길동&quot;, age=30, address='서울시 용산구 이촌동') 이름: 홍길동 나이: 30 주소: 서울시 용산구 이촌동 12personal_info(name=&quot;홍길동&quot;, address='서울시 용산구 이촌동', age=30)# 순서가 달라도 그래도 출력되네. 굳. 이름: 홍길동 나이: 30 주소: 서울시 용산구 이촌동 30.3 키워드 인수와 딕셔너리 언패킹 사용하기1234567def personal_info(name,age,address): print('이름:', name) print('나이:', age) print('주소:', address) x = {'name': '홍길동', 'age':30, 'address':'서울시 용산구 이촌동'} personal_info(**x) # 왜 출력안됨 ???? 12# personal_info(**{'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'})# 이거 하니까 행 겁나 많이 나옴.... 30.3.1 **처럼 두번하는 이 12345# 딕셔너리는 **처럼 *를 두 번 사용할까요? # 왜냐하면 딕셔너리는 키-값 쌍 형태로 값이 저장되어 있기 때문입니다.x = {'name': '홍길동', 'age':30, 'address':'서울시 용산구 이촌동'}personal_info(*x)## 이것도 행 엄청 나다. 12345#x = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}#&gt;&gt;&gt; personal_info(*x)#이름: name#나이: age#주소: address 12345#&gt;&gt;&gt; x = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}#&gt;&gt;&gt; personal_info(**x)#이름: 홍길동#나이: 30#주소: 서울시 용산구 이촌동 30.3.2 키워드 인수를 사용하는 가변 인수 함수 만들기 1234567def personal_info(**kwargs): #keyword arguments for kw, arg in kwargs.item(): print(kw,':',arg, sep='')peronsal_info(name='홍길동')personal_info(name='홍길동', age=30, address='서울시 용산구 이촌동') --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-106-2abc425a519f&gt; in &lt;module&gt;() 4 5 ----&gt; 6 peronsal_info(name='홍길동') 7 personal_info(name='홍길동', age=30, address='서울시 용산구 이촌동') NameError: name 'peronsal_info' is not defined 12345x = {'name': 홍길동}personal_info(**x)name: 홍길동y = {'name': '홍길동', 'age'=30, 'address': '서울시 용산구 이촌동'}personal_info(**y) File &quot;&lt;ipython-input-109-69cbf1af3b78&gt;&quot;, line 4 y = {'name': '홍길동', 'age'=30, 'address': '서울시 용산구 이촌동'} ^ SyntaxError: invalid syntax 1234567def personal_info(**kwargs): if 'name' in kwargs: # in 으로 딕셔너리 안에 특정 키가 있는지 확인 print('이름: ', kwargs['name']) if 'age' in kwargs: print('나이: ', kwargs['age']) if 'address' in kwargs: print('주소: ', kwargs['address']) 참고 : 고정 인수와 가변 인수(키워드 인수)를 함께 사용하기 고정 인수와 가변 인수를 사용할 때는 다음과 같이 고정 매개 변수를 먼저 지정하고, 그 다음 매개변수에 **를 붙여주면 됩니다. 1234567def personal_info(name, **kwargs): print(name) print(kwargs)persnal_info('홍길동')personal_info('홍길동', age=30, address='서울시 용산구 이촌동')personal_info(**{'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}) --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-112-8aa719c056a6&gt; in &lt;module&gt;() 3 print(kwargs) 4 ----&gt; 5 persnal_info('홍길동') 6 personal_info('홍길동', age=30, address='서울시 용산구 이촌동') 7 personal_info(**{'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}) NameError: name 'persnal_info' is not defined 참고 : 위치 인수와 키워드 인수를 함께 사용하기 1234def custom_print(*args, **kwargs): print(*args, **kwargs)custom_print(1,2,3,sep=':', end='') 1:2:3 #30.4 매개변수에 초깃값 지정하기 123456def personal_info(name, age, affreess='비공개'): print('이름:',name) print('나이:',age) print('주소:',address)personal_info('홍길동', 30) 이름: 홍길동 나이: 30 --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-117-3309fa8c57ec&gt; in &lt;module&gt;() 4 print('주소:',address) 5 ----&gt; 6 personal_info('홍길동', 30) &lt;ipython-input-117-3309fa8c57ec&gt; in personal_info(name, age, affreess) 2 print('이름:',name) 3 print('나이:',age) ----&gt; 4 print('주소:',address) 5 6 personal_info('홍길동', 30) NameError: name 'address' is not defined","link":"/2022/06/28/day0628_assignment/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/06/29/hello-world/"},{"title":"pandas 기본 자료형","text":"index 랑 column 하나를 합치면 series로 본다. data frame는 보는지 구분하기. = 칼럼2개랑 인덱스 하나 https://pandas.pydata.org/docs/reference/frame.html 에서 시리즈랑 데이터 프레임의 methods 같아 보이지만 다르다. 데이터프레임/ groupby() –&gt;ㅣ 그룹 바이 클래스+a가 클래스 정의한 메소드 예) 데이터 프레임info()b의 클래스 정의 메소드 info() 메서드 존재하지 않음 시리즈랑 데이터프레임의 methods가 다르다. 이부분 참고해서 쓰도록.시리즈의 메소드인데 데이터 프레임에 넣어쓰면 에러 걸릴 확률이 높다. 라이브러리 불러오기1234import pandas as pdimport numpy as npprint(&quot;pandas version:&quot;, pd.__version__)print(&quot;numpy version:&quot;, np.__version__) pandas version: 1.3.5 numpy version: 1.21.6 구글 드라이브 연동하기12from google.colab import drivedrive.mount('/content/drive') Mounted at /content/drive 12345DATA_PATH = '/content/drive/MyDrive/Colab Notebooks/Human_AI/Basic/Chapter 3. pandas/data/Lemonade2016.csv'lemonade = pd.read_csv(DATA_PATH)print(type(lemonade))lemonade.info() &lt;class 'pandas.core.frame.DataFrame'&gt; &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 32 entries, 0 to 31 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Date 31 non-null object 1 Location 32 non-null object 2 Lemon 32 non-null int64 3 Orange 32 non-null int64 4 Temperature 32 non-null int64 5 Leaflets 31 non-null float64 6 Price 32 non-null float64 dtypes: float64(2), int64(3), object(2) memory usage: 1.9+ KB float = 실수형 int = 정수형 int64 = 파생 변수형(64비트에서 128비트로 키운다면 부피공간이 커짐) = object = 문자형 데이터 맛보기 1print(lemonade.head(3)) Date Location Lemon Orange Temperature Leaflets Price 0 7/1/2016 Park 97 67 70 90.0 0.25 1 7/2/2016 Park 98 67 72 90.0 0.25 2 7/3/2016 Park 110 77 71 104.0 0.25 1print(lemonade.tail(7)) Date Location Lemon Orange Temperature Leaflets Price 25 7/25/2016 Park 156 113 84 135.0 0.50 26 7/26/2016 Park 176 129 83 158.0 0.35 27 7/27/2016 Park 104 68 80 99.0 0.35 28 7/28/2016 Park 96 63 82 90.0 0.35 29 7/29/2016 Park 100 66 81 95.0 0.35 30 7/30/2016 Beach 88 57 82 81.0 0.35 31 7/31/2016 Beach 76 47 82 68.0 0.35 기술 통계량 보는 함수 describe() 1print(lemonade.describe()) Lemon Orange Temperature Leaflets Price count 32.000000 32.000000 32.000000 31.000000 32.000000 mean 116.156250 80.000000 78.968750 108.548387 0.354688 std 25.823357 21.863211 4.067847 20.117718 0.113137 min 71.000000 42.000000 70.000000 68.000000 0.250000 25% 98.000000 66.750000 77.000000 90.000000 0.250000 50% 113.500000 76.500000 80.500000 108.000000 0.350000 75% 131.750000 95.000000 82.000000 124.000000 0.500000 max 176.000000 129.000000 84.000000 158.000000 0.500000 std : 표준편차 오렌지의 표준편차가 작은걸 보니 (=평균에서 퍼진 정도가 작다)들쑥날쑥하게 판매되지 않고 평균에 근접해서 팔린다. 범주형 데이터 빈도수 구하기 1lemonade['Location'].value_counts() Beach 17 Park 15 Name: Location, dtype: int64 1print(type(lemonade['Location'])) &lt;class 'pandas.core.series.Series'&gt; 참고) .value_counts() 가 하나의 method 다. = series method다. 행과 열 다루기 sold(판매량) 컬럼(=피쳐=feature)을 추가하기 12lemonade['sold'] = 0print(lemonade.head(5)) Date Location Lemon Orange Temperature Leaflets Price sold 0 7/1/2016 Park 97 67 70 90.0 0.25 0 1 7/2/2016 Park 98 67 72 90.0 0.25 0 2 7/3/2016 Park 110 77 71 104.0 0.25 0 3 7/4/2016 Beach 134 99 76 98.0 0.25 0 4 7/5/2016 Beach 159 118 78 135.0 0.25 0 12lemonade['sold'] = lemonade['Lemon'] + lemonade['Orange']print(lemonade.head(5)) Date Location Lemon Orange Temperature Leaflets Price sold 0 7/1/2016 Park 97 67 70 90.0 0.25 164 1 7/2/2016 Park 98 67 72 90.0 0.25 165 2 7/3/2016 Park 110 77 71 104.0 0.25 187 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 Revenue(매출) = 단가 x 판매d 12lemonade['Revenue'] = lemonade['Price'] * lemonade['sold']print(lemonade.head(3)) Date Location Lemon Orange Temperature Leaflets Price sold \\ 0 7/1/2016 Park 97 67 70 90.0 0.25 164 1 7/2/2016 Park 98 67 72 90.0 0.25 165 2 7/3/2016 Park 110 77 71 104.0 0.25 187 Revenue 0 41.00 1 41.25 2 46.75 drop() 함수 사용해서 열 제거 또는 행 제거 1234# 컬럼 제거(=열제거)col_drop = lemonade.drop('sold', axis=1) #솔드를 제거할것인데 솔드는 열(axis=1)이다.print(col_drop.head()) Date Location Lemon Orange Temperature Leaflets Price Revenue 0 7/1/2016 Park 97 67 70 90.0 0.25 41.00 1 7/2/2016 Park 98 67 72 90.0 0.25 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 46.75 3 7/4/2016 Beach 134 99 76 98.0 0.25 58.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 69.25 123# 행 제거row_drop = lemonade.drop(2, axis=0) # 두번째에 있는, 행(axis=00을 제거 하기print(row_drop.head()) Date Location Lemon Orange Temperature Leaflets Price sold \\ 0 7/1/2016 Park 97 67 70 90.0 0.25 164 1 7/2/2016 Park 98 67 72 90.0 0.25 165 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 Revenue 0 41.00 1 41.25 3 58.25 4 69.25 5 43.00 123# 행 제거row_drop = lemonade.drop([0,1,2],axis=0) # 리스트로 제거할 수도 있다.print(row_drop.head()) Date Location Lemon Orange Temperature Leaflets Price sold \\ 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 6 7/6/2016 Beach 103 69 82 90.0 0.25 172 7 7/7/2016 Beach 143 101 81 135.0 0.25 244 Revenue 3 58.25 4 69.25 5 43.00 6 43.00 7 61.00 데이터 인덱1print(lemonade[4:7]) Date Location Lemon Orange Temperature Leaflets Price sold \\ 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 6 7/6/2016 Beach 103 69 82 90.0 0.25 172 Revenue 4 69.25 5 43.00 6 43.00 특정 값만 추출 filter 1lemonade['Location'] == 'Beach' 0 False 1 False 2 False 3 True 4 True 5 True 6 True 7 True 8 True 9 True 10 True 11 True 12 True 13 True 14 True 15 True 16 True 17 True 18 False 19 False 20 False 21 False 22 False 23 False 24 False 25 False 26 False 27 False 28 False 29 False 30 True 31 True Name: Location, dtype: bool 123# False는 거르고 True만 골라서 결괏값 나옴.# 공식 :데이터[데이터 컬럼 == 특정값]lemonade[lemonade['Location'] == 'Beach'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price sold Revenue 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 6 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 7 7/7/2016 Beach 143 101 81 135.0 0.25 244 61.00 8 NaN Beach 123 86 82 113.0 0.25 209 52.25 9 7/9/2016 Beach 134 95 80 126.0 0.25 229 57.25 10 7/10/2016 Beach 140 98 82 131.0 0.25 238 59.50 11 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 12 7/12/2016 Beach 130 95 84 99.0 0.25 225 56.25 13 7/13/2016 Beach 109 75 77 99.0 0.25 184 46.00 14 7/14/2016 Beach 122 85 78 113.0 0.25 207 51.75 15 7/15/2016 Beach 98 62 75 108.0 0.50 160 80.00 16 7/16/2016 Beach 81 50 74 90.0 0.50 131 65.50 17 7/17/2016 Beach 115 76 77 126.0 0.50 191 95.50 30 7/30/2016 Beach 88 57 82 81.0 0.35 145 50.75 31 7/31/2016 Beach 76 47 82 68.0 0.35 123 43.05 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-b71d9559-6993-43ed-b29d-34d3975d956f button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-b71d9559-6993-43ed-b29d-34d3975d956f'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1lemonade['Temperature'] &gt;= 80 0 False 1 False 2 False 3 False 4 False 5 True 6 True 7 True 8 True 9 True 10 True 11 True 12 True 13 False 14 False 15 False 16 False 17 False 18 True 19 False 20 False 21 False 22 True 23 True 24 True 25 True 26 True 27 True 28 True 29 True 30 True 31 True Name: Temperature, dtype: bool 1lemonade[lemonade['Temperature'] &gt;= 80] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price sold Revenue 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 6 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 7 7/7/2016 Beach 143 101 81 135.0 0.25 244 61.00 8 NaN Beach 123 86 82 113.0 0.25 209 52.25 9 7/9/2016 Beach 134 95 80 126.0 0.25 229 57.25 10 7/10/2016 Beach 140 98 82 131.0 0.25 238 59.50 11 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 12 7/12/2016 Beach 130 95 84 99.0 0.25 225 56.25 18 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 22 7/22/2016 Park 112 75 80 108.0 0.50 187 93.50 23 7/23/2016 Park 120 82 81 117.0 0.50 202 101.00 24 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 25 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 26 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 27 7/27/2016 Park 104 68 80 99.0 0.35 172 60.20 28 7/28/2016 Park 96 63 82 90.0 0.35 159 55.65 29 7/29/2016 Park 100 66 81 95.0 0.35 166 58.10 30 7/30/2016 Beach 88 57 82 81.0 0.35 145 50.75 31 7/31/2016 Beach 76 47 82 68.0 0.35 123 43.05 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-fefd7f67-978c-4fca-a953-69a4402571cb button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-fefd7f67-978c-4fca-a953-69a4402571cb'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1lemonade['Temperature'] &gt;= 80, lemonade['Orange'] &gt;= 100 (0 False 1 False 2 False 3 False 4 False 5 True 6 True 7 True 8 True 9 True 10 True 11 True 12 True 13 False 14 False 15 False 16 False 17 False 18 True 19 False 20 False 21 False 22 True 23 True 24 True 25 True 26 True 27 True 28 True 29 True 30 True 31 True Name: Temperature, dtype: bool, 0 False 1 False 2 False 3 False 4 True 5 False 6 False 7 True 8 False 9 False 10 False 11 True 12 False 13 False 14 False 15 False 16 False 17 False 18 False 19 False 20 False 21 False 22 False 23 False 24 False 25 True 26 True 27 False 28 False 29 False 30 False 31 False Name: Orange, dtype: bool) 12lemonade[ (lemonade['Temperature'] &gt;= 70) &amp; (lemonade['Orange'] &gt;= 80) &amp; (lemonade['Location'] == &quot;Park&quot; )] # 여러 가지 조건식으로 데이터 추리기 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price sold Revenue 18 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 19 7/19/2016 Park 122 85 78 113.0 0.50 207 103.50 23 7/23/2016 Park 120 82 81 117.0 0.50 202 101.00 24 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 25 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 26 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-80320a22-7b24-4c18-a306-c15a3bb26c3d button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-80320a22-7b24-4c18-a306-c15a3bb26c3d'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123# 데이터[데이터 칼럼== 특정값]lemonade.loc[lemonade['Temperature']&gt;= 80, ['Date','sold'] ]############## 파이썬 자료에서 loc랑 iloc인가 비교하기 중요############## .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date sold 5 7/6/2016 172 6 7/6/2016 172 7 7/7/2016 244 8 NaN 209 9 7/9/2016 229 10 7/10/2016 238 11 7/11/2016 282 12 7/12/2016 225 18 7/18/2016 223 22 7/22/2016 187 23 7/23/2016 202 24 7/24/2016 203 25 7/25/2016 269 26 7/26/2016 305 27 7/27/2016 172 28 7/28/2016 159 29 7/29/2016 166 30 7/30/2016 145 31 7/31/2016 123 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-33af7aa7-7d80-48f0-8db0-8c45f8021f15 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-33af7aa7-7d80-48f0-8db0-8c45f8021f15'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; ilocvs loc 문법적 차이 확인 12lemonade.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price sold Revenue 0 7/1/2016 Park 97 67 70 90.0 0.25 164 41.00 1 7/2/2016 Park 98 67 72 90.0 0.25 165 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-962c2a26-2292-4fe7-a89e-2352b07fd58f button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-962c2a26-2292-4fe7-a89e-2352b07fd58f'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; iloc—&gt; 숫자만 들어감 12print(lemonade.iloc[0:3, 0:2] # [0,3] index로 적용되고 반면에 Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park loc : 숫자(x) 라벨 = 글자 (숫자 문자 동시) 1234print(lemonade.loc [0:2,['Date', 'Location']])# [0:2] index로 적용되지 않고 데이터 옆 숫자(칼럼명으)로 인식된다.# loc만 쓰다가 충분히 익숙해지면 그때 iloc쓰자.# loc만 쭉 써도 무방하다. Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park 데이터 정렬 sort_value() 1print(lemonade[['Date', 'Temperature', 'Revenue']].sort_values(by=['Revenue']).head(5)) Date Temperature Revenue 0 7/1/2016 70 41.00 1 7/2/2016 72 41.25 6 7/6/2016 82 43.00 5 7/6/2016 82 43.00 31 7/31/2016 82 43.05 123lemonade.head()print(lemonade[['Date', 'Temperature', 'Revenue']].sort_values(by=['Temperature','Revenue']).head(5)) Date Temperature Revenue 0 7/1/2016 70 41.00 20 7/20/2016 70 56.50 2 7/3/2016 71 46.75 1 7/2/2016 72 41.25 16 7/16/2016 74 65.50 1print(lemonade[['Date', 'Temperature', 'Revenue']].sort_values(by=['Temperature', 'Revenue'], ascending = [True, False]).head(5)) Date Temperature Revenue 20 7/20/2016 70 56.50 0 7/1/2016 70 41.00 2 7/3/2016 71 46.75 1 7/2/2016 72 41.25 16 7/16/2016 74 65.50 Group by123df = lemonade.groupby(by='Location'). count()print(df)print(type(df)) Date Lemon Orange Temperature Leaflets Price sold Revenue Location Beach 16 17 17 17 17 17 17 17 Park 15 15 15 15 14 15 15 15 &lt;class 'pandas.core.frame.DataFrame'&gt; 12345678df = lemonade.groupby(by='Location').count()print(df)print(type(df))df[['Date', 'Lemon']]print(df.iloc[0:1, 0:2])print(df.loc['Park', ['Date', 'Lemon']])############################################################################## Date Lemon Orange Temperature Leaflets Price sold Revenue Location Beach 16 17 17 17 17 17 17 17 Park 15 15 15 15 14 15 15 15 &lt;class 'pandas.core.frame.DataFrame'&gt; Date Lemon Location Beach 16 17 Date 15 Lemon 15 Name: Park, dtype: int64 간단한 피벗 테이블 만들기 1lemonade.groupby('Location')['Revenue'].agg([max, min,sum, np. mean]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } max min sum mean Location Beach 95.5 43.0 1002.8 58.988235 Park 134.5 41.0 1178.2 78.546667 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8c3e5d62-27b3-4e49-88b4-94147d42a9d5 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8c3e5d62-27b3-4e49-88b4-94147d42a9d5'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1lemonade.groupby('Location')['Revenue'].agg([max, min, sum, np.mean]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } max min sum mean Location Beach 95.5 43.0 1002.8 58.988235 Park 134.5 41.0 1178.2 78.546667 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-cfa59f0b-adae-4ab3-8501-98c3a18604ad button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-cfa59f0b-adae-4ab3-8501-98c3a18604ad'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1lemonade.groupby('Location')['Revenue','sold','Temperature'].agg([max, min, sum, np.mean]) /usr/local/lib/python3.7/dist-packages/ipykernel_launcher.py:1: FutureWarning: Indexing with multiple keys (implicitly converted to a tuple of keys) will be deprecated, use a list instead. &quot;&quot;&quot;Entry point for launching an IPython kernel. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { text-align: right; } Revenue sold Temperature max min sum mean max min sum mean max min sum mean Location Beach 95.5 43.0 1002.8 58.988235 282 123 3422 201.294118 84 74 1355 79.705882 Park 134.5 41.0 1178.2 78.546667 305 113 2855 190.333333 84 70 1172 78.133333 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-93a14472-c6c5-43e2-8e66-763f4766a1e6 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-93a14472-c6c5-43e2-8e66-763f4766a1e6'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt;","link":"/2022/06/29/day0629/"},{"title":"pandas 기본 자료형","text":"파이썬 주요 라이브러리 “””- Machine learning 정형 데이터 싸이킷런 (scijit-learn) Deep learning 비정형 데이터 Tensorflow(구글), Pytorch(페이스북) 혼공머: Tensorflow 실제 상용 서비스 -Tensorflow vs R&amp;D - Pytorch “”” 생선 분류 도미, 곤들매기, 농어, 등등 이 생선들을 프로그램으로 분류하려고한다.-30cm 도미라고 알려줘 1234fish_length = 31if fish_length &gt;= 30: print(&quot;도미&quot;) 도미 데이터 수집12345# 도미의 길이bream_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0]# 도미의 무게bream_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0] 데이터 가공 여기서는 생략 데이터 시각화 여러 인사이트 확인을 위해 시각화, 통계 수치 계산 탐색적 자료 분석(EDA : Exploratory Data Analysis) 이거는 참고만하기. 12345678import matplotlib.pyplot as pltplt.scatter(bream_length, bream_weight)plt.xlabel('length')plt.ylabel('weight')plt.show() ## 이 방법 쓰지말기. 12345678import matplotlib.pyplot as pltfig, ax = plt.subplots()ax.scatter(bream_length, bream_weight)ax.set_xlabel('length')ax.set_ylabel('length')plt.show() #이처럼 많이쓰니까 이렇게 쓰기. 외우기.암기. 빙어 데이터 준비하기 12345678smelt_length = [9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]smelt_weight = [6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9]plt.scatter(bream_length, bream_weight)plt.scatter(smelt_length, smelt_weight)plt.xlabel('length')plt.ylabel('weight')plt.show() 두개의 리스트 합치 12length = bream_length + smelt_lengthweight = bream_weight + smelt_weight 2차원 리스트로 만든다. 12345fish_data = [[l,w]for l, w in zip(length,weight)]print(fish_data)## [l,m]에서 m을 w로 해놔서 계속 오류가 났었네.. [[25.4, 242.0], [26.3, 290.0], [26.5, 340.0], [29.0, 363.0], [29.0, 430.0], [29.7, 450.0], [29.7, 500.0], [30.0, 390.0], [30.0, 450.0], [30.7, 500.0], [31.0, 475.0], [31.0, 500.0], [31.5, 500.0], [32.0, 340.0], [32.0, 600.0], [32.0, 600.0], [33.0, 700.0], [33.0, 700.0], [33.5, 610.0], [33.5, 650.0], [34.0, 575.0], [34.0, 685.0], [34.5, 620.0], [35.0, 680.0], [35.0, 700.0], [35.0, 725.0], [35.0, 720.0], [36.0, 714.0], [36.0, 850.0], [37.0, 1000.0], [38.5, 920.0], [38.5, 955.0], [39.5, 925.0], [41.0, 975.0], [41.0, 950.0], [9.8, 6.7], [10.5, 7.5], [10.6, 7.0], [11.0, 9.7], [11.2, 9.8], [11.3, 8.7], [11.8, 10.0], [11.8, 9.9], [12.0, 9.8], [12.2, 12.2], [12.4, 13.4], [13.0, 12.2], [14.3, 19.7], [15.0, 19.9]] 라벨링 해준다 = 지도해준다= 지도 학습 12fish_target = [1] * 35 + [0] *14print(fish_target) [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 모델1234567from sklearn.neighbors import KNeighborsClassifier# 클래스 인스턴스화kn = KNeighborsClassifier()# 모형 학습kn.fit(fish_data, fish_target) KNeighborsClassifier() 12# 예측 정확도kn.score(fish_data, fish_target) 실제 예측을 해보자 새로운 물고기 도착했습니다. 길이 : 30, 몸무게 : 60 1234567891011ac_length = int(input(&quot;물고기 길이를 입력하세요...&quot;))ac_weight = int(input(&quot;물고기 무게를 입력하세요...&quot;))preds = int(kn.predict([[ac_length, ac_weight]]))print(preds)if preds == 1: print(&quot;도미&quot;)else: print(&quot;빙어&quot;) 물고기 길이를 입력하세요...10 물고기 무게를 입력하세요...50 0 빙어 123456789101112131415161718''' blog 파일에 넣는 행동 = 백업해두기 위해서(파일 그대로) 왜냐하면 lysyeah.github.io 에 저장할 때 html 확장자로 저장되기 때문에 수정할 때 불편하다. 구글 코랩에서 .ipynb 다운로드 후---&gt; anaconda --&gt; open the file(= .ipynb)--&gt; convert to MD (Mark Down) = saving.md--&gt; sourcetree로 add, commit, push 하기.--&gt; blog 파일을 우클릭 해서 파이참으로 켠다--&gt; hexo 해서 실제 블로그에 올려야하는데 잘 모르겠다.'''","link":"/2022/06/29/day0629_ml/"},{"title":"0630_ml_ch2","text":"파이썬 주요 라이브러리 “”” Machine learning 정형 데이터 싸이킷런 (scijit-learn) Deep learning 비정형 데이터 Tensorflow(구글), Pytorch(페이스북) 혼공머: Tensorflow 실제 상용 서비스 -Tensorflow vs R&amp;D - Pytorch “”” 생선 분류 도미, 곤들매기, 농어, 등등 이 생선들을 프로그램으로 분류하려고한다. 30cm 이상은 도미라고 알려줘 12345fish_length = 909090if fish_length &gt;= 30: print(&quot;도미&quot;)else : print(&quot;몰라종&quot;) 도미 데이터 수집12345# 도미의 길이bream_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0]# 도미의 무게bream_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0] 데이터 가공 여기서는 생략 데이터 시각화 여러 인사이트 확인을 위해 시각화, 통계 수치 계산 탐색적 자료 분석(EDA : Exploratory Data Analysis) 이거는 참고만하기. 123456import matplotlib.pyplot as pltplt.scatter(bream_length, bream_weight)plt.xlabel('length')plt.ylabel('weight')plt.show() ## 이 방법 쓰지말기. 안좋대. 1234567import matplotlib.pyplot as pltfig, ax = plt.subplots()ax.scatter(bream_length, bream_weight)ax.set_xlabel('length')ax.set_ylabel('weight')plt.show() # 이처럼 많이쓰니까 이렇게 쓰기. 외우기.암기. 빙어 데이터 준비하기 12345678smelt_length = [9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]smelt_weight = [6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9]plt.scatter(bream_length, bream_weight)plt.scatter(smelt_length, smelt_weight)plt.xlabel('length')plt.ylabel('weight')plt.show() 두개의 리스트 합치기 12length = bream_length + smelt_lengthweight = bream_weight + smelt_weight 2차원 리스트로 만든다. 12345fish_data = [[l,w]for l, w in zip(length,weight)]print(fish_data)## [l,m]에서 m을 w로 해놔서 계속 오류가 났었네.. 라벨링 해준다 = 지도해준다= 지도 학습 12fish_target = [1] * 35 + [0] *14print(fish_target) 모델12345678from sklearn.neighbors import KNeighborsClassifier# 클래스 인스턴스화kn = KNeighborsClassifier()# 모형 학습 # =독립변수, =종속변수kn.fit(fish_data, fish_target) 12# 예측 정확도 (재검사)kn.score(fish_data, fish_target) 실제 예측을 해보자 새로운 물고기 도착했습니다. 길이 : 30, 몸무게 : 60 1234567891011ac_length = int(input(&quot;물고기 길이를 입력하세요...&quot;))ac_weight = int(input(&quot;물고기 무게를 입력하세요...&quot;))preds = int(kn.predict([[ac_length, ac_weight]]))print(preds)if preds == 1: print(&quot;도미&quot;)else: print(&quot;빙어&quot;) 물고기 무게를 입력하세요...10 0 빙어 12345678910111213''' blog 파일에 넣는 행동 = 백업해두기 위해서(파일 그대로) 왜냐하면 lysyeah.github.io 에 저장할 때 html 확장자로 저장되기 때문에 수정할 때 불편하다. 구글 코랩에서 .ipynb 다운로드 후---&gt; anaconda --&gt; open the file(= .ipynb)--&gt; convert to MD (Mark Down) = saving.md--&gt; sourcetree로 add, commit, push 하기.--&gt; blog 파일을 우클릭 해서 파이참으로 켠다--&gt; hexo 해서 실제 블로그에 올려야하는데 잘 모르겠다.''' '\\n blog 파일에 넣는 행동 = 백업해두기 위해서(파일 그대로)\\n 왜냐하면 lysyeah.github.io 에\\n 저장할 때 html 확장자로 저장되기 때문에 \\n 수정할 때 불편하다.\\n\\n 구글 코랩에서 .ipynb 다운로드 후---&gt; anaconda \\n--&gt; open the file(= .ipynb)\\n--&gt; convert to MD (Mark Down) = saving.md\\n--&gt; sourcetree로 add, commit, push 하기.\\n--&gt; blog 파일을 우클릭 해서 파이참으로 켠다\\n--&gt; hexo 해서 실제 블로그에 올려야하는데 잘 모르겠다.\\n' 분석의흐름 데이터수집 데이터 가공 데이터 시각화 데이터 (예측_ 모델링) 예측 평가지표** 알고리즘 공부 ** 중요하긴한데 무궁무진…ㅜㅠ R : 데이터(통계) 모델링 변수(=컬럼=피처)간의 관계 가설 검정이 중요하다. 공통점 : 해석 !!! 보고서를 작성 (상사, 갑, 의사결정자) 현재의 나 : 면접 자료 면접 자료 : 소스코드 &amp; 파워포인트 1## 새로운 모델 제안 하이퍼 파라미터 세팅 n_neighbors = 49 default : 100% 머신 러닝 알고리즘의 두가지 큰 흐름 선형 모델 : 선형회귀, 로지스틱 회귀, 서포트 벡터 머신 의사결정트리 모델 : 1975년 의사결정트리 모델, KNN, 랜덤포레스트 부스팅계열 : LightGBM(2017), XHboost(2016) 선형 회귀, 로지스틱회귀, 랜덤포레스트, –LightGBM(=XGBoost)– 12345kn49 = KNeighborsClassifier(n_neighbors=49)kn49.fit(fish_data,fish_target)kn49.score(fish_data, fish_target)# = 정확도 = 71퍼센트 0.7142857142857143 12345678fish_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0, 9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]fish_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0, 6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9] 2차원 파이선 리스트 작성후 라벨링하기. 1234fish_data = [[l, w] for l, w in zip(fish_length, fish_weight)]fish_target = [1] * 35 + [0] * 14print(fish_target[0:40:5])print(fish_data[0:40:5]) [1, 1, 1, 1, 1, 1, 1, 0] [[25.4, 242.0], [29.7, 450.0], [31.0, 475.0], [32.0, 600.0], [34.0, 575.0], [35.0, 725.0], [38.5, 920.0], [9.8, 6.7]] Sample 도미 35마리, 빙어 14마리 49개의 샘플 존재 처음 35개를 훈련 / 나머지 14를 테스트 12345678910111213141516from sklearn.neighbors import KNeighborsClassifier# 클래스 인스턴스화kn = KNeighborsClassifier()# 훈련 세트로 0:34 인덱스 활용train_input = fish_data[:35]train_target = fish_target[:35]# 테스트 세트로 35:0 인덱스 활용test_input = fish_data[35:]test_target = fish_target[35:]#모형학습kn = kn.fit(train_input, train_target)print(kn.score(test_input, test_target)) 0.0 샘플링 편향 훈련세트와 테스트 세트가 골고루 섞이지 않음 샘플링 작123456import numpy as npinput_arr = np.array(fish_data)target_arr = np.array(fish_target)print(input_arr[0:49:7])print(input_arr.shape, target_arr.shape) [[ 25.4 242. ] [ 30. 390. ] [ 32. 600. ] [ 34. 685. ] [ 36. 850. ] [ 9.8 6.7] [ 11.8 9.9]] (49, 2) (49,) 12345# random으로 배열을 만들거나 저장np. random.seed(42)index = np.arange(49)np.random.shuffle(index)print(index) [13 45 47 44 17 27 26 25 31 19 12 4 34 8 3 6 40 41 46 15 9 16 24 33 30 0 43 32 5 29 11 36 1 21 2 37 35 23 39 10 22 18 48 20 7 42 14 28 38] 77p 1234567train_input = input_arr[index[:35]]train_target = target_arr[index[:35]]test_input = input_arr[index[35:]]test_target = target_arr[index[35:]]print(input_arr[13], train_input[0]) [ 32. 340.] [ 32. 340.] 시각화1train_input[:,0] array([32. , 12.4, 14.3, 12.2, 33. , 36. , 35. , 35. , 38.5, 33.5, 31.5, 29. , 41. , 30. , 29. , 29.7, 11.3, 11.8, 13. , 32. , 30.7, 33. , 35. , 41. , 38.5, 25.4, 12. , 39.5, 29.7, 37. , 31. , 10.5, 26.3, 34. , 26.5]) 1234567import matplotlib.pyplot as plt fig, ax = plt.subplots()ax.scatter(train_input[:, 0], train_input[:, 1])ax.scatter(test_input[:, 0], test_input[:, 1])ax.set_xlabel(&quot;length&quot;)ax.set_ylabel(&quot;weight&quot;)plt.show() ##두 번째 머신러닝 프로그램 12kn.fit(train_input, train_target)kn.score(test_input, test_target) 1.0 1kn.predict(test_input) # 예측 데이터 array([0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0]) 1test_target # 실제 데이터 array([0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0]) 데이터 전처리 머신러닝 시 , 데이터 전처리 결측치 처리, 이상치 처 12345678fish_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0, 9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]fish_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0, 6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9] 123# column_stack 활용np.column_stack(([1,2,3],[4,5,6])) array([[1, 4], [2, 5], [3, 6]]) 12fish_data = np.column_stack((fish_length, fish_weight))print(fish_data[ : 5]) [[ 25.4 242. ] [ 26.3 290. ] [ 26.5 340. ] [ 29. 363. ] [ 29. 430. ]] 종속변수 = y = 타깃 데이터 = target 12fish_target = np.concatenate((np.ones(35),np.zeros(14)))print(fish_target) [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] #Python 데이터과학NumPy 기본 Pandas 데이터 가공 (=dplyr) Scipy 과학, 수학, 통계 statsmodels 통계 sklearn 머신러닝 tensorflow, pytorch scikit-learn 훈련세트와 테스트 세트 나누기1234567891011from sklearn.model_selection import train_test_splittrain_input, test_input, train_target, test_target = train_test_split( # 독립변수, 종속변수 fish_data, fish_target, random_state = 42)train_input.shape, test_input.shape, train_target.shape, train_target.shape# 여기 있는 것들 수시로 쳐서 익숙해지기.# 42는 관용적으로 쓰는 수치. 딱히 의미는 없음.. ((36, 2), (13, 2), (36,), (36,)) p92 도미와 빙어가 잘 섞여있니? 1print(test_target) [1. 0. 0. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.] 35(도미) : 14(빙어) 2.5 : 14 테스트 셋 (비율) 3.3 : 14 층화 샘플링 기초 통계, 설문조사 비율 여론조사 남성 속옷을 구매하는 비율 (남자 : 여자 = 9 : 1) 신제품 ( 남자5, 여자5) 12345678train_input, test_input, train_target, test_target = train_test_split( # 독립변수, 종속변수 fish_data, fish_target, stratidy=fish_target, random_state = 42)train_input.shape, test_input.shape, train_target.shape, train_target.shape 1print(test_target) [1. 0. 0. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.] 테스트 세트의 비율이 2.25:1 수상한 도미 한 마리1234from sklearn.neighbors import KNeighborsClassifierkn = KNeighborsClassifier()kn.fit(train_input, train_target)kn.score(test_input, test_target) 1.0 1print(kn.predict([[25,150]])) [0.] 123456789import matplotlib.pyplot as pltdistances, indexes = kn.kneighbors([[25, 150]])fig, ax = plt.subplots()ax. scatter(train_input[:,0], train_input[:,1])ax.scatter(25,150,marker='^')plt.xlabel('length')plt.ylabel('weight')plt.show() 1234567plt.scatter(train_input[:,0], train_input[:,1])plt.scatter(25, 150, marker='^')plt.scatter(train_input[indexes,0], train_input[indexes,1], marker='D')plt.xlim((0, 1000))plt.xlabel('length')plt.ylabel('weight')plt.show() p.98 두 특성(길이, 무게) 의 값이 놓인 범위가 매우 다르다. 두 특성의 스케일이 다름. 스케일이 같도록 통계 처리가 필요. feature exngineer 머신러닝 전체 데이터 전처리 ( 결측치처리, 이상치 처리) 데이터 분리 피처링 엔지니어링 표준점1234mean= np.mean(train_input, axis=0)std = np.std(train_input, axis=0)print(mean,std) [ 26.175 418.08888889] [ 10.21073441 321.67847023] 표준 점수 구하기 12345# 브로드 캐스팅 : 서로 다른 배열을 계산할 때train_scaled = (train_input - mean ) / std print( train_input.shape, mean.shape, std.shape ) (36, 2) (2,) (2,) 12345plt.scatter(train_scaled[:,0], train_scaled[:,1])plt.scatter(25, 150, marker='^')plt.xlabel('length')plt.ylabel('weight')plt.show() 123456new = ([25, 150] - mean) / stdplt.scatter(train_scaled[:,0], train_scaled[:,1])plt.scatter(new[0], new[1], marker='^')plt.xlabel('length')plt.ylabel('weight')plt.show() 통계처리 전 : KNN –&gt; 예측이 틀림통계처리 후 : KNN –&gt; 맞음– 통계처리 –&gt; Feature Engineering 모형학습 1kn.fit(train_scaled, train_target) KNeighborsClassifier() 123#kn.score(test_input, test_taeget)test_scaled = (test_input - mean ) / stdkn.score(test_scaled, test_target) 1.0 예측 1print(kn.predict([new])) [1.] 1234567distances, indexes = kn.kneighbors([new])plt.scatter(train_scaled[:,0], train_scaled[:,1])plt.scatter(new[0], new[1], marker='^')plt.scatter(train_scaled[indexes,0], train_scaled[indexes,1], marker='D')plt.xlabel('length')plt.ylabel('weight')plt.show()","link":"/2022/06/30/day0630_ml_ch2/"},{"title":"0630_ml_ch3","text":"K- 최근접 이웃 회귀 지도 학습 알고리즘은 크게 분류와 회귀 지도 학습 : 종속변수 존재 분류 : 도미와 빙어 분류 문제를 해결 회귀 : 통계에서 들었던.. y = ax + b –&gt; 수치 예측 데이터 불러오기12import numpy as npprint(np.__version__) 1.21.6 1234567891011121314151617perch_length = np.array( [8.4, 13.7, 15.0, 16.2, 17.4, 18.0, 18.7, 19.0, 19.6, 20.0, 21.0, 21.0, 21.0, 21.3, 22.0, 22.0, 22.0, 22.0, 22.0, 22.5, 22.5, 22.7, 23.0, 23.5, 24.0, 24.0, 24.6, 25.0, 25.6, 26.5, 27.3, 27.5, 27.5, 27.5, 28.0, 28.7, 30.0, 32.8, 34.5, 35.0, 36.5, 36.0, 37.0, 37.0, 39.0, 39.0, 39.0, 40.0, 40.0, 40.0, 40.0, 42.0, 43.0, 43.0, 43.5, 44.0] )perch_weight = np.array( [5.9, 32.0, 40.0, 51.5, 70.0, 100.0, 78.0, 80.0, 85.0, 85.0, 110.0, 115.0, 125.0, 130.0, 120.0, 120.0, 130.0, 135.0, 110.0, 130.0, 150.0, 145.0, 150.0, 170.0, 225.0, 145.0, 188.0, 180.0, 197.0, 218.0, 300.0, 260.0, 265.0, 250.0, 250.0, 300.0, 320.0, 514.0, 556.0, 840.0, 685.0, 700.0, 700.0, 690.0, 900.0, 650.0, 820.0, 850.0, 900.0, 1015.0, 820.0, 1100.0, 1000.0, 1100.0, 1000.0, 1000.0] ) 1234567import matplotlib.pyplot as pltfig, ax = plt.subplots() #객체지향plt.scatter(perch_length, perch_weight)plt.xlabel('length')plt.ylabel('weight')plt.show() 12345from sklearn.model_selection import train_test_splittrain_input, test_input, train_target,test_target= train_test_split(perch_length, perch_weight, random_state=42)train_input.shape, test_input.shape, train_target.shape, test_target.shapeprint(train_input.ndim) 1 1차원 배열 –&gt; 2차원 배열 1234train_input = train_input.reshape(-1,1)test_input = test_input.reshape(-1,1)print(train_input.shape, test_input.shape)print(train_input.ndim) (42, 1) (14, 1) 2 결정 계수 정확하다 0~1 사이의 지표 1로 수렴할수록 예측 모형에 잘 맞다. 123456789from sklearn.neighbors import KNeighborsRegressorknr = KNeighborsRegressor()# 모형 학습knr.fit(train_input, train_target) # 테스트 세트의 점수를 확인한다. print(knr.score(test_input, test_target)) 0.992809406101064 123456789from sklearn.metrics import mean_absolute_error# 테스트 세트에 대한 예측을 만든다.test_prediction = knr.predict(test_input)#테스트 세트에 대한 평균 절댓값 오차를 계산한다.mae = mean_absolute_error(test_target, test_prediction)print(mae) 19.157142857142862 예측이 평균적으로 19g 정도 다르다. 확실한 건 오차가 존재한다. 19g 정도가 의미하는게 뭐지? 개선 : 17g 개선 … 계속해서 오차를 줄인다. 1print(knr.score(train_input, train_target)) 0.9698823289099254 과대적합 vs 과소적합 매우 힘듦. 도망 가자… 우리…by. 선우정아 과대적합 : 훈련세트 점수 좋음, 테스트 점수 매우 운 좋음 과소적합 : 테스트 세트의 점수가 매우 좋음 결론 : 제대로 모형이 훈련되지 않은 것이다. 모형을 서비스에 합칠 수 없음. 12print(&quot;훈련평가:&quot;, knr.score(train_input, train_target))print(&quot;테스트 평가:&quot;, knr.score(train_input, train_target)) 훈련평가: 0.9698823289099254 테스트 평가: 0.9698823289099254 123456# 이웃의 개수를 3으로 재지정 knr.n_neighbors = 3knr.fit(train_input, train_target)print(&quot;훈련 평가:&quot;, knr.score(train_input, train_target))print(&quot;테스트 평가:&quot;, knr.score(test_input, test_target)) 훈련 평가: 0.9804899950518966 테스트 평가: 0.9746459963987609","link":"/2022/06/30/day0630_ml_ch3/"},{"title":"practise_2","text":"Practise_2튜플은 어떻게 만들까??? 12345t1 = ()t2 = (1,)t3 = (1,2,3)t4 = 1,2,3t5 = ('a','b',('ab','cd'))","link":"/2022/06/30/Practise_2/"},{"title":"day0701_ml_ch3","text":"3-2 선형회귀p.130 12345678910111213141516171819import numpy as npperch_length = np.array([8.4, 13.7, 15.0, 16.2, 17.4, 18.0, 18.7, 19.0, 19.6, 20.0, 21.0, 21.0, 21.0, 21.3, 22.0, 22.0, 22.0, 22.0, 22.0, 22.5, 22.5, 22.7, 23.0, 23.5, 24.0, 24.0, 24.6, 25.0, 25.6, 26.5, 27.3, 27.5, 27.5, 27.5, 28.0, 28.7, 30.0, 32.8, 34.5, 35.0, 36.5, 36.0, 37.0, 37.0, 39.0, 39.0, 39.0, 40.0, 40.0, 40.0, 40.0, 42.0, 43.0, 43.0, 43.5, 44.0])perch_weight = np.array([5.9, 32.0, 40.0, 51.5, 70.0, 100.0, 78.0, 80.0, 85.0, 85.0, 110.0, 115.0, 125.0, 130.0, 120.0, 120.0, 130.0, 135.0, 110.0, 130.0, 150.0, 145.0, 150.0, 170.0, 225.0, 145.0, 188.0, 180.0, 197.0, 218.0, 300.0, 260.0, 265.0, 250.0, 250.0, 300.0, 320.0, 514.0, 556.0, 840.0, 685.0, 700.0, 700.0, 690.0, 900.0, 650.0, 820.0, 850.0, 900.0, 1015.0, 820.0, 1100.0, 1000.0, 1100.0, 1000.0, 1000.0])print(perch_length.shape, perch_weight.shape) # 확인해본다고 프린트해봄 (56,) (56,) 데이터 가공- 123456# 훈련세트와 테스트 세트로 나눈 후, 1차원 --&gt; 2차원 배열로 전환from sklearn.model_selection import train_test_split# 훈련 세트와 테스트 세트로 나눕니다train_input, test_input, train_target, test_target = train_test_split( perch_length, perch_weight, random_state=42) 123## 1차원 --&gt; 2차원 배열train_input = train_input.reshape(-1, 1)test_input = test_input.reshape(-1, 1) 시각화 -&gt; 재가공 모델 12345from sklearn.neighbors import KNeighborsRegressorknr = KNeighborsRegressor(n_neighbors=3)# k-최근접 이웃 회귀 모델을 훈련합니다knr.fit(train_input, train_target) KNeighborsRegressor(n_neighbors=3) 모델 평가모델 예측 서비스를 함 12# 농어 길이 = 50print(knr.predict([[50]])) [1033.33333333] 모형 평가를 위한 시각화 들여쓴 블록 1import matplotlib.pyplot as plt 123456789101112131415distances, indexs = knr.kneighbors([[50]])# 훈련 세트의 산점도를 그려보자.# 훈련세트의 산점도를 그린다.plt.scatter(train_input, train_target)# 훈련 세트 중에서 이웃 샘플만 다시 그린다.plt.scatter(train_input[indexes], train_target[indexes], marker='D')#50cm 농어 데이터plt.scatter(50,1033,marker='^')plt.xlabel('length')plt.ylabel('weight')plt.show() 책 저자가 하고싶은 말 = 머신러닝 = 알고리즘 머신러닝 / 딥러닝 = 실험 실험을 한다 - 다양한 방법을 써본다 –&gt;&gt; 어떻게 몇개의 알고리즘이 선택받았을까??? 다양한 알고리즘을 써본다. 1print(np.mean(train_target[indexes])) 1033.3333333333333 1print(knr.predict([[100]])) [1033.33333333] 123456789101112131415# 100cm 농어의 이웃을 구합니다distances, indexes = knr.kneighbors([[100]])# 훈련 세트의 산점도를 그립니다\u001fplt.scatter(train_input, train_target)# 훈련 세트 중에서 이웃 샘플만 다시 그립니다\u001fplt.scatter(train_input[indexes], train_target[indexes], marker='D')# 100cm 농어 데이터plt.scatter(100, 1033, marker='^')plt.xlabel('length')plt.ylabel('weight')plt.show()## 시각화 하라고 했던 대로 해보자.## ax.xlabel_이렇게 하는거. 선형회1from sklearn.linear_model import LinearRegression 1234## Pythonlr = LinearRegression()# 선형 회귀에 대해 학습lr.fit(train_input,train_target) LinearRegression() 12# 50cm 농어에 대한 예측print(lr.predict([[100]])) [3192.69585141] 선형 회귀의 모형 기울기 1print(lr.coef_, lr.intercept_) [39.01714496] -709.0186449535477 선형회귀 다항 회귀 농어 1cm = - 650g # 뭐야.. 직선의 기술기 대신, 곡선의 기울기를 쓰자. 직선:1차 , 곡선:2차 $무게 = a길이^2 + b길이 + 절편$ 1 123456789# 훈련 세트의 산점도를 그립니다\u001fplt.scatter(train_input, train_target)# 15에서 50까지 1차 방정식 그래프를 그립니다plt.plot([15, 50], [15*lr.coef_+lr.intercept_, 50*lr.coef_+lr.intercept_])# 50cm 농어 데이터plt.scatter(50, 1241.8, marker='^')plt.xlabel('length')plt.ylabel('weight')plt.show() 12345678train_poly = np.column_stack((train_input ** 2, train_input))test_poly = np.column_stack((test_input ** 2, test_input))print(train_poly.shape, test_poly.shape)print(&quot;----train_polt----&quot;)print(train_poly[0:3])print(&quot;----test_polt----&quot;)print(test_poly[0:3]) (42, 2) (14, 2) ----train_polt---- [[384.16 19.6 ] [484. 22. ] [349.69 18.7 ]] ----test_polt---- [[ 70.56 8.4 ] [324. 18. ] [756.25 27.5 ]] 1234lr = LinearRegression()lr.fit(train_poly, train_target)print(lr.predict([[50**2, 50]])) [1573.98423528] 1print(lr.coef_, lr.intercept_) [ 1.01433211 -21.55792498] 116.0502107827827 무게 = 1.01 x $길이^2$ - 21.6 x 길이 +116.5 1234567891011# 구간별 직선을 그리기 위해 15에서 49까지 정수 배열을 만듭니다point = np.arange(15, 50)# 훈련 세트의 산점도를 그립니다plt.scatter(train_input, train_target)# 15에서 49까지 2차 방정식 그래프를 그립니다plt.plot(point, 1.01*point**2 - 21.6*point + 116.05)# 50cm 농어 데이터plt.scatter([50], [1574], marker='^')plt.xlabel('length')plt.ylabel('weight')plt.show() 12print(lr.score(train_poly, train_target))print(lr.score(test_poly, test_target)) 0.9706807451768623 0.9775935108325122 3-3 특성 공학과 규제 p.150. 혼자 해보는 챕터. 1import pandas as pd #pd는 관례적으로 사용하는 판다스의 별칭이다. 123df = pd.read_csv('https://bit.ly/perch_csv_data')perch_full = df.to_numpy()print(perch_full) [[ 8.4 2.11 1.41] [13.7 3.53 2. ] [15. 3.82 2.43] [16.2 4.59 2.63] [17.4 4.59 2.94] [18. 5.22 3.32] [18.7 5.2 3.12] [19. 5.64 3.05] [19.6 5.14 3.04] [20. 5.08 2.77] [21. 5.69 3.56] [21. 5.92 3.31] [21. 5.69 3.67] [21.3 6.38 3.53] [22. 6.11 3.41] [22. 5.64 3.52] [22. 6.11 3.52] [22. 5.88 3.52] [22. 5.52 4. ] [22.5 5.86 3.62] [22.5 6.79 3.62] [22.7 5.95 3.63] [23. 5.22 3.63] [23.5 6.28 3.72] [24. 7.29 3.72] [24. 6.38 3.82] [24.6 6.73 4.17] [25. 6.44 3.68] [25.6 6.56 4.24] [26.5 7.17 4.14] [27.3 8.32 5.14] [27.5 7.17 4.34] [27.5 7.05 4.34] [27.5 7.28 4.57] [28. 7.82 4.2 ] [28.7 7.59 4.64] [30. 7.62 4.77] [32.8 10.03 6.02] [34.5 10.26 6.39] [35. 11.49 7.8 ] [36.5 10.88 6.86] [36. 10.61 6.74] [37. 10.84 6.26] [37. 10.57 6.37] [39. 11.14 7.49] [39. 11.14 6. ] [39. 12.43 7.35] [40. 11.93 7.11] [40. 11.73 7.22] [40. 12.38 7.46] [40. 11.14 6.63] [42. 12.8 6.87] [43. 11.93 7.28] [43. 12.51 7.42] [43.5 12.6 8.14] [44. 12.49 7.6 ]] 1234567891011import numpy as npperch_weight = np.array( [5.9, 32.0, 40.0, 51.5, 70.0, 100.0, 78.0, 80.0, 85.0, 85.0, 110.0, 115.0, 125.0, 130.0, 120.0, 120.0, 130.0, 135.0, 110.0, 130.0, 150.0, 145.0, 150.0, 170.0, 225.0, 145.0, 188.0, 180.0, 197.0, 218.0, 300.0, 260.0, 265.0, 250.0, 250.0, 300.0, 320.0, 514.0, 556.0, 840.0, 685.0, 700.0, 700.0, 690.0, 900.0, 650.0, 820.0, 850.0, 900.0, 1015.0, 820.0, 1100.0, 1000.0, 1100.0, 1000.0, 1000.0] ) 123from sklearn.model_selection import train_test_splittrain_input, test_input, train_target, test_target = train_test_split(perch_full, perch_weight, random_state=42) 1from sklearn.preprocessing import PolynomialFeatures 123poly = PolynomialFeatures()poly.fit([[2, 3]])print(poly.transform([[2, 3]])) [[1. 2. 3. 4. 6. 9.]] 123poly = PolynomialFeatures(include_bias=False)poly.fit([[2, 3]])print(poly.transform([[2, 3]])) [[2. 3. 4. 6. 9.]] 1234poly = PolynomialFeatures(include_bias=False)poly.fit(train_input)train_poly = poly.transform(train_input) 1print(train_poly.shape) (42, 9) 1poly.get_feature_names_out() array(['x0', 'x1', 'x2', 'x0^2', 'x0 x1', 'x0 x2', 'x1^2', 'x1 x2', 'x2^2'], dtype=object) 1test_poly = poly.transform(test_input) 다중 회귀 모델 훈련하기.12345from sklearn.linear_model import LinearRegressionlr = LinearRegression()lr.fit(train_poly, train_target)print(lr.score(train_poly, train_target)) 0.9903183436982124 1print(lr.score(test_poly, test_target)) 0.9714559911594134 12345poly = PolynomialFeatures(degree=5, include_bias=False)poly.fit(train_input)train_poly = poly.transform(train_input)test_poly = poly.transform(test_input) 1print(train_poly.shape) (42, 55) 12lr.fit(train_poly, train_target)print(lr.score(train_poly, train_target)) 0.9999999999991097 1print(lr.score(test_poly, test_target)) -144.40579242684848 1## 규제 1234567from sklearn.preprocessing import StandardScalerss = StandardScaler()ss.fit(train_poly)train_scaled = ss.transform(train_poly)test_scaled = ss.transform(test_poly) 릿지12345from sklearn.linear_model import Ridgeridge = Ridge()ridge.fit(train_scaled, train_target)print(ridge.score(train_scaled, train_target)) 0.9896101671037343 12print(ridge.score(test_scaled, test_target)) 0.9790693977615397 1234import matplotlib.pyplot as plttrain_score = []test_score = [] 123456789alpha_list = [0.001, 0.01, 0.1, 1, 10, 100]for alpha in alpha_list: # 릿지 모델을 만듭니다 ridge = Ridge(alpha=alpha) # 릿지 모델을 훈련합니다 ridge.fit(train_scaled, train_target) # 훈련 점수와 테스트 점수를 저장합니다 train_score.append(ridge.score(train_scaled, train_target)) test_score.append(ridge.score(test_scaled, test_target)) 12345plt.plot(np.log10(alpha_list), train_score)plt.plot(np.log10(alpha_list), test_score)plt.xlabel('alpha')plt.ylabel('R^2')plt.show() 12345ridge = Ridge(alpha=0.1)ridge.fit(train_scaled, train_target)print(ridge.score(train_scaled, train_target))print(ridge.score(test_scaled, test_target)) 0.9903815817570366 0.9827976465386926 라쏘12345from sklearn.linear_model import Lassolasso = Lasso()lasso.fit(train_scaled, train_target)print(lasso.score(train_scaled, train_target)) 0.989789897208096 1print(lasso.score(test_scaled, test_target)) 0.9800593698421883 123456789101112train_score = []test_score = []alpha_list = [0.001, 0.01, 0.1, 1, 10, 100]for alpha in alpha_list: # 라쏘 모델을 만듭니다 lasso = Lasso(alpha=alpha, max_iter=10000) # 라쏘 모델을 훈련합니다 lasso.fit(train_scaled, train_target) # 훈련 점수와 테스트 점수를 저장합니다 train_score.append(lasso.score(train_scaled, train_target)) test_score.append(lasso.score(test_scaled, test_target)) /usr/local/lib/python3.7/dist-packages/sklearn/linear_model/_coordinate_descent.py:648: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.878e+04, tolerance: 5.183e+02 coef_, l1_reg, l2_reg, X, y, max_iter, tol, rng, random, positive /usr/local/lib/python3.7/dist-packages/sklearn/linear_model/_coordinate_descent.py:648: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.297e+04, tolerance: 5.183e+02 coef_, l1_reg, l2_reg, X, y, max_iter, tol, rng, random, positive 12345plt.plot(np.log10(alpha_list), train_score)plt.plot(np.log10(alpha_list), test_score)plt.xlabel('alpha')plt.ylabel('R^2')plt.show() 12345lasso = Lasso(alpha=10)lasso.fit(train_scaled, train_target)print(lasso.score(train_scaled, train_target))print(lasso.score(test_scaled, test_target)) 0.9888067471131867 0.9824470598706695 1print(np.sum(lasso.coef_ == 0)) 40","link":"/2022/07/01/day0701_ml_ch3/"},{"title":"day0701_ml_ch4","text":"p175 Chapter 4 다양한 분류 알고리즘04-1 로지스틱 회귀 선형 회귀에서 출발. 이진 분류 문제 해결. 클래스 확률을 예측 딥러닝에서도 사용함. p.177 x가 사각형, 삼각형, 원일 확률 0.3, 0.5, 0.2 데이터 불러오기 species : 종속변수Y 독립변수 : weight, length, diagonal, height, width 1234import pandas as pdfish = pd.read_csv('https://bit.ly/fish_csv_data')fish.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Species Weight Length Diagonal Height Width 0 Bream 242.0 25.4 30.0 11.5200 4.0200 1 Bream 290.0 26.3 31.2 12.4800 4.3056 2 Bream 340.0 26.5 31.1 12.3778 4.6961 3 Bream 363.0 29.0 33.5 12.7300 4.4555 4 Bream 430.0 29.0 34.0 12.4440 5.1340 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-6bc0ac18-2825-440f-a811-79c1cd913f23 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-6bc0ac18-2825-440f-a811-79c1cd913f23'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 데이터 탐색123# 종속변수부터 확인하기 !!!print(pd.unique(fish['Species'])) ['Bream' 'Roach' 'Whitefish' 'Parkki' 'Perch' 'Pike' 'Smelt'] 데이터 가공123# pandas 데이터 프레임에서 numpy 배열로 변환fish_input = fish[['Weight','Length','Diagonal','Height','Width']].to_numpy()fish_input.shape (159, 5) 1print(fish_input[:5]) [[242. 25.4 30. 11.52 4.02 ] [290. 26.3 31.2 12.48 4.3056] [340. 26.5 31.1 12.3778 4.6961] [363. 29. 33.5 12.73 4.4555] [430. 29. 34. 12.444 5.134 ]] 타깃 데이터 , 종속변수 , Y 123fish_target = fish['Species'].to_numpy()print(fish_target.shape)print(fish_target[0:5]) (159,) ['Bream' 'Bream' 'Bream' 'Bream' 'Bream'] 데이터 분리 훈련 데이터와 테스트 데이터 분리 123456789from sklearn.model_selection import train_test_split# 임의 샘플링train_input, test_input, train_target, test_target = train_test_split( fish_input, fish_target, random_state=42)# 층화 샘플링하기. 나중에 해보자. 표준화 전처리 여기에서도 훈련 세트의 통계 값으로 테스트 세트를 변환해야 한다는 점을 잊지 마세요..! 데이터 가공 숫자 결측치가 존재, 평균값으로 대체 원본 데이터 평균 대치 (x) 훈련 데이터와 테스트 데이터 분리 데이터누수 (leakage) 훈련 데이터 평균값 70을 대치 o 테스트 데이터 평균값 75을 대치 x 모든 데이터 평균값 72.5을 대치 x https://scikit-learn.org/stable/common_pitfalls.html 참고하기 pipeline 사용하기 p.97 기준을 맞춰라 –&gt; 데이터 표준화 (표준점수) 수동으로 mean, std 12# p.100# train_scaled = (train_input - mean)/ std = ss.tranform(train_input) 12345678from sklearn.preprocessing import StandardScalerss = StandardScaler()ss.fit(train_input)# 잊지말라는 말 : ss.fit(train_input)에다가 ss.fit(test.input)을 넣지말라는 말임.train_scaled = ss.transform(train_input)test_scaled = ss.transform(test_input) 모형 만들기 K-최근접 이 123456from sklearn.neighbors import KNeighborsClassifierkn = KNeighborsClassifier(n_neighbors=3)kn.fit(train_scaled, train_target)print(kn.score(train_scaled, train_target))print(kn.score(test_scaled,test_target)) 0.8907563025210085 0.85 타깃값 확인 알파벳 순으로 정 1print(kn.predict(test_scaled[0:5])) ['Perch' 'Smelt' 'Pike' 'Perch' 'Perch'] 다중 분류 1print 5개 샘플에 대한 예측은 어떤 확률이냐 1234import numpy as npproba = kn.predict_proba(test_scaled[:5])print(kn.classes_)print(np.round(proba, decimals=4)) ['Bream' 'Parkki' 'Perch' 'Pike' 'Roach' 'Smelt' 'Whitefish'] [[0. 0. 1. 0. 0. 0. 0. ] [0. 0. 0. 0. 0. 1. 0. ] [0. 0. 0. 1. 0. 0. 0. ] [0. 0. 0.6667 0. 0.3333 0. 0. ] [0. 0. 0.6667 0. 0.3333 0. 0. ]] 첫 번째 클래스 Perch 100% 확률로 Perch로 예측 Br Park Perch[0. 0. 1. 0. 0. 0. 0. ] 네 번째 클래스 perch 66.7% 확률로 Perch 예측 33.3% 확률로 Roach 예측 회귀 식 y = ax + b 양변에 로그를 취해서 파이 = 1 / (1+e^-z)가 된다. ( = 로지스틱 함수 ) 수식을 유도하는 것은 중요치 않으나 흐름은 알자. 로지스틱 회귀로 이진 분류 수행하기1234char_arr = np.array(['A', 'B', 'C', 'D', 'E']) # train_scaled dataprint(char_arr[[True, False, True, False, False]]) # bream_smelt_indexes data ['A' 'C'] 도미와 빙어의 행만 골라낸다1 123456bream_smelt_indexes = (train_target == 'Bream') | (train_target == 'Smelt')print(bream_smelt_indexes)train_bream_smelt = train_scaled[bream_smelt_indexes]target_bream_smelt = train_target[bream_smelt_indexes]train_scaled.shape, train_bream_smelt.shape [ True False True False False False False True False False False True False False False True True False False True False True False False False True False False True False False False False True False False True True False False False False False True False False False False False True False True False False True False False False True False False False False False False True False True False False False False False False False False False True False True False False True True False False False True False False False False False True False False False True False True False False True True False False False False False False False False True True False False True False False] ((119, 5), (33, 5)) 모델 만들기1234from sklearn.linear_model import LogisticRegressionlr = LogisticRegression()lr.fit(train_bream_smelt, target_bream_smelt) LogisticRegression() 12# 클래스를 예측print(lr.predict(train_bream_smelt[:5])) ['Bream' 'Smelt' 'Bream' 'Bream' 'Bream'] 확률 값 구하기 1print(lr.predict_proba(train_bream_smelt[:5])) [[0.99759855 0.00240145] [0.02735183 0.97264817] [0.99486072 0.00513928] [0.98584202 0.01415798] [0.99767269 0.00232731]] 1print(lr.classes_) ['Bream' 'Smelt'] 분류 기준 : threshold 임계값 설정 #트레스홀드 도미 vs 빙어 [0.51 , 0.49] [0.90, 0.1] 계수와 절편 1print(lr.coef_, lr.intercept_) [[-0.4037798 -0.57620209 -0.66280298 -1.01290277 -0.73168947]] [-2.16155132] 12decision = lr.decision_function(train_bream_smelt[:5])print(decision) [-6.02927744 3.57123907 -5.26568906 -4.24321775 -6.0607117 ] z값을 확률값으로 변환 12from scipy.special import expitprint(expit(decision)) [0.00240145 0.97264817 0.00513928 0.01415798 0.00232731] 다중 분류 수행하기 (= 이중분류의 확장판)12345678910# 하이퍼 파라미터 세팅 (hyperparameter setting)# 모형을 튜닝# 순정을 쓰세요# 모형 결과의 과대적합 또는 과소적합을 방지하기 위한 것lr = LogisticRegression(C = 20, max_iter = 1000)lr.fit(train_scaled, train_target)print(lr.score(train_scaled,train_target))print(lr.score(test_scaled,test_target)) 0.9327731092436975 0.925 1print(lr.predict(test_scaled[:5])) ['Perch' 'Smelt' 'Pike' 'Roach' 'Perch'] 12proba = lr.predict_proba(test_scaled[:5])print(np.round(proba,decimals=3)) [[0. 0.014 0.841 0. 0.136 0.007 0.003] [0. 0.003 0.044 0. 0.007 0.946 0. ] [0. 0. 0.034 0.935 0.015 0.016 0. ] [0.011 0.034 0.306 0.007 0.567 0. 0.076] [0. 0. 0.904 0.002 0.089 0.002 0.001]] 1print(lr.classes_) ['Bream' 'Parkki' 'Perch' 'Pike' 'Roach' 'Smelt' 'Whitefish'] 다중 분류의 경우, 선형 방정식의 모습은? 분류 7 개 의 선형방정식이 나온다./ 컬럼값 5개 1print(lr.coef_.shape, lr.intercept_.shape) (7, 5) (7,) 평가 지표 (책에 없는 내용) 회귀 평가 지표 결정계수 ( 121 page ) +1- { (타깃 - 예측)^2의 합 / (타깃-평균)^2의 합 } MAE, MSE, RMSE ( 실제 - 예측 ) = 오차 MAE (Mean Absoulte Error) : 오차의 절댓값의 평균 ) 평균 MSE ( Mean Squared Error ) : 오차의 제곱의 평균 RMSE ( Root Mean Squared Error ) : MSE의 제곱근 결정계수 : 1에 수렴할수록 좋은 모델이다. MAE, MSE, RMSE : 0에 수렴할수록 좋은 모델이다. 123456789101112131415161718192021import numpy as npfrom sklearn.metrics import mean_absolute_error, mean_squared_error, r2_scoretrue = np.array([1,2,3,2,3,5,4,6,5,6,7,8,8]) # 실제값preds = np.array([1,1,2,2,3,4,4,5,5,6,6,5,8]) # 예측값# 절대값의 오차의 평균mae = mean_absolute_error(true, preds)print(mae)# 제곱 오차의 평균mse = mean_squared_error(true, preds)print(mse)# mse의 제곱근rmse = np.sqrt(mse)print(rmse)# 결정계수r2 = r2_score(true, preds)print(r2) 0.6153846153846154 1.0769230769230769 1.0377490433255416 0.7848699763593381 분류 평가지표 오차 행렬 실제값 [ 빙어, 도미, 도미, 빙어, 도미] # 실제 [ 빙어, 빙어, 도미, 빙어, 빙어] # 예측 이것을 슬랙에 올린 표처럼 만들기(오차행렬) TP ( 빙어를 빙어로 예측한 것 ) : 2TN ( 도미를 도미로 예측한 것 ) : 1FN ( 실제 도미, 예측 빙어 ) : 2FP ( 실제 빙어, 예측 도미 ) : 0 모형의 정확도 3/5 : 60% 정확도 이렇게 TP, TN, FN, FP 설정한 것, 잘 보자. 수동으로 했지만 나중에 자동으로 설정할 수 있다. TP, TN, FP, FN 5,5,3,7 정확도 : ( tp+tv ) / tp+tb+fp+fn 정밀도(양성으로 예측한 값 중에서 양성인 값) = precision : tp / tp + fp 재현율(실제로 양성인 것 중에서 양성인 것) = Recall : tp / tp + fn 코로나 검사 양성(1) : 음성(99) 머신러닝 모형 : 98% / 정밀도 99 인간 음성진단 : 99% / 정밀도 95 결론 : 정밀도를 보고 판단을 해야한다. 정확도로만 판단할 수 없다. 검사자가 실제는 양성, 진단은 음성으로 내림 = 심각….평가지표 판단하는 것 꼭 할 줄 알아야한다.** 로그손실() : ROC Curve (= AUC ) 123456from sklearn.metrics import confusion_matrixtrue = [0,1,1,0,0]preds = [1,0,0,0,0]confusion_matrix(true,preds) array([[2, 1], [2, 0]])","link":"/2022/07/01/day0701_ml_ch4/"},{"title":"day0704_ml","text":"확률적 경사 하강법 점진적 학습 (step, 보폭) 학습률 XGBoost, LightGBM, 딥러닝(이미지 분류, 자연어 처리, 옵티마이저) 신경망 이미지 데이터, 자연어 자율주행 하루 데이터 1TB –&gt; 학습 한꺼번에 다 모델을 학습 어려움 샘플링, 배치, 에포크, 오차(=손실=loss)가 가장 작은 지점을 찾아야 함. 결론적으로, 확률적 경사 하강법 손실함수 로지스틱 손실 함수 123import pandas as pd fish = pd.read_csv(&quot;https://bit.ly/fish_csv_data&quot;)fish.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 159 entries, 0 to 158 Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Species 159 non-null object 1 Weight 159 non-null float64 2 Length 159 non-null float64 3 Diagonal 159 non-null float64 4 Height 159 non-null float64 5 Width 159 non-null float64 dtypes: float64(5), object(1) memory usage: 7.6+ KB 입력 데이터와 타깃 데이터 분리 1234fish_input = fish[['Weight', 'Length', 'Diagonal', 'Height', 'Width']].to_numpy()fish_target = fish['Species'].to_numpy()fish_input.shape, fish_target.shape ((159, 5), (159,)) 훈련 세트와 테스트 데이터 분리 12345from sklearn.model_selection import train_test_split train_input, test_input, train_target, test_target = train_test_split( # input, target, 옵션... fish_input, fish_target, random_state=42) 훈련 세트와 테스트 세트의 특성 표준화 무게, 길이, 대각선 길이, 높이, 너비 표준화 처리 진행 12345678from sklearn.preprocessing import StandardScalerss = StandardScaler()ss.fit(train_input)train_scaled = ss.transform(train_input)test_scaled = ss.transform(test_input)# train_scaled[:5] 모델링 확률적 경사 하강법 123456from sklearn.linear_model import SGDClassifier sc = SGDClassifier(loss = 'log', max_iter = 10, random_state=42)sc.fit(train_scaled, train_target)print(sc.score(train_scaled, train_target))print(sc.score(test_scaled, test_target)) 0.773109243697479 0.775 /usr/local/lib/python3.7/dist-packages/sklearn/linear_model/_stochastic_gradient.py:700: ConvergenceWarning: Maximum number of iteration reached before convergence. Consider increasing max_iter to improve the fit. ConvergenceWarning, partial_fit() 메서드 사용하면 추가 학습. 123sc.partial_fit(train_scaled, train_target) print(sc.score(train_scaled, train_target))print(sc.score(test_scaled, test_target)) 0.8151260504201681 0.85 에포크와 과대/과소적합 에포크 숫자가 적으면 –&gt; 덜 학습 early_stopping 에포크 숫자를 1000, 손실 10, 9, 8, , 3 3에 도달한 시점이 150 1234567891011121314import numpy as np sc = SGDClassifier(loss='log', random_state = 42)train_score = []test_score = []classes = np.unique(train_target)# 300번 에포크 훈련을 반복# 훈련 할 때마다, train_score, test_score 추가를 한다. for _ in range(0, 300): sc.partial_fit(train_scaled, train_target, classes = classes) train_score.append(sc.score(train_scaled, train_target)) test_score.append(sc.score(test_scaled, test_target)) 시각화 12345import matplotlib.pyplot as plt plt.plot(train_score)plt.plot(test_score)plt.legend([&quot;train&quot;, &quot;test&quot;])plt.show() Chapter 5 트리 알고리즘 ( 화이트 와인을 찾아랏 )결정트리 wine 데이터 가져오기 123import pandas as pd wine = pd.read_csv('https://bit.ly/wine_csv_data')print(wine.head()) alcohol sugar pH class 0 9.4 1.9 3.51 0.0 1 9.8 2.6 3.20 0.0 2 9.8 2.3 3.26 0.0 3 9.8 1.9 3.16 0.0 4 9.4 1.9 3.51 0.0 데이터 가공하기 12data = wine[['alcohol', 'sugar', 'pH']].to_numpy()target = wine['class'].to_numpy() 1wine['class'].value_counts() 1.0 4898 0.0 1599 Name: class, dtype: int64 훈련데이터 분리 1234567from sklearn.model_selection import train_test_splittrain_input, test_input, train_target, test_target = train_test_split( data, target, test_size = 0.2, random_state=42)train_input.shape, test_input.shape, train_target.shape, test_target.shape ((5197, 3), (1300, 3), (5197,), (1300,)) 표준화 처리 123456from sklearn.preprocessing import StandardScalerss = StandardScaler()ss.fit(train_input)train_scaled = ss.transform(train_input)test_scaled = ss.transform(test_input) 모델 만들기 12345678910111213from sklearn.tree import DecisionTreeClassifierimport matplotlib.pyplot as plt from sklearn.tree import plot_tree dt = DecisionTreeClassifier(max_depth = 8, random_state=42)# 4에 있는 'dt =' 에 dt = DecisionTreeClassifier(criterion = 'entropy', max_depth = 8, random_state=42) 넣으면 엔트로피로 나온다.# [15]번에.dt.fit(train_scaled, train_target)print(dt.score(train_scaled, train_target))print(dt.score(test_scaled, test_target))plt.figure(figsize=(10, 7))plot_tree(dt)plt.show() 0.9003271117952665 0.8576923076923076 훈련 정확도는 99.6% 테스트 정확도는 85.9%–&gt; 과대적합이 일어남 노드란 무엇인가? 0 이면 레드 와인 :1599 개 1 이면 화이트 와인 :4898 개 123plt.figure(figsize=(10,7))plot_tree(dt,max_depth=1,filled=True,feature_names=['alcohol','sugar','pH'])plt.show() 불순도 ( gini 불순도 : 0.5 ) 비율 레드와인 : 화이트와인 = 5:5 (데이터 비율) 밸류 값이 5대5 일때 지니 값이 가장 크다..(분류가 잘 됐다) 불순도 0.5가 기준이다. 한 범주안에서 서로 다른 데이터가 얼마나 섞여 있는지 나타냄 흰색과 검은색이 각각 50개 섞여있다. = 불순도 0.5 흰색과 검은색 완전 100% 분리가됨 흰색 노드 불순도 최소 = 0 검은색 노드 불순도 최소 = 0 엔트로피 ( Entropy ) 불확실한 정도를 의미한다. 0~1 사이 흰색과 검은색이 각각 50개씩 섞여있따. 엔트로피 최대 = 1 완전 분리됨 흰색 노드 엔트로피 최소 = 0 검은색 노드 엔트로피 최소 = 0 불순도로 하든 엔트로피로 하든 결과값은 거의 동일하다.위에 [모델 만들기]에서 비교해볼 수 있다. 특성 중요도 어떤 특성이 결정 트리 모델에 영향을 주었는가? 123print(dt.feature_importances_)## sugar 값이 가장 높은 걸 보았을 때 당도가 가장 중요하다는 결론을 도출할 수 있다.### 특성 중요도는!! 인과 관계와는 관련이 없다. [0.17976778 0.65284899 0.16738324] 현업에서의 적용 현업에서 DecisionTreeClassifier ( 1970 년대에 이 개념이 나왔다. ) 그렇기 때문에 업그레이드를 한 논문을 쓰게 된다. 랜덤포레스트, XGBoost, ,,,, etc = 엄ㅁㅁㅁㅁㅁㅁ청 많다 그래서 다 못한다. 검증 세트 훈련 세트와 테스트 세트로 나누었다. 훈련 : 교과서( 로 공부하는 것 훈련세트, 모의 평가 ) 검증 : 강남대성 모의고사 테스트 : 6월, 9월 평가 실전 : 수능 12345678910111213141516import pandas as pd wine = pd.read_csv('https://bit.ly/wine_csv_data')#print(wine.head())data = wine[['alcohol', 'sugar', 'pH']].to_numpy()target = wine['class'].to_numpy()# 훈련 80%# 테스트 20%train_input, test_input, train_target, test_target = train_test_split( data, target, test_size = 0.2, random_state=42)train_input.shape, test_input.shape, train_target.shape, test_target.shape ((5197, 3), (1300, 3), (5197,), (1300,)) 1234567# 훈련 80%# 검증 20%sub_input, val_input, sub_target, val_target = train_test_split( train_input, train_target, test_size= 0.2, random_state=42)sub_input.shape, val_input.shape, sub_target.shape, val_target.shape ((4157, 3), (1040, 3), (4157,), (1040,)) 훈련 데이터 : train (x), sub_input, sub_target이 훈련데이터이다. 검증 데이터 : val_input, val_target 테스트 데이터 : teset_input, test_target 모형 만들기 123456from sklearn.tree import DecisionTreeClassifierdt = DecisionTreeClassifier(random_state=42)dt.fit(sub_input, sub_target)print(&quot;훈련성과:&quot;,dt.score(sub_input, sub_target))print(&quot;검증성과:&quot;, dt.score(val_input,val_target))print(&quot;마지막 검증:&quot;, dt.score(test_input, test_target)) 훈련성과: 0.9971133028626413 검증성과: 0.864423076923077 마지막 검증: 0.8569230769230769 교차 검증 데이터 셋을 반복 분할 For loop 샘플링 편향적일 수 있음. 그래서 교차 검증을 한다고 해서 무조건 정확도가 올라가는 것이 아니다. 단지, 모형을 ‘안정적’으로 만들어줄 뿐이다. 방지도 해준다. 1234567891011import numpy as npfrom sklearn. model_selection import KFolddf = np.array([1,2,3,4,5,6,7,8,9,10])df# 데이터를 K 폴드로 나눈다.folds = KFold(n_splits=5, shuffle=True)for train_idx, valid_idx in folds.split(df): print(f'훈련데이터:{df[train_idx]}, 검증데이터 : {df[valid_idx]}') 훈련데이터:[ 1 2 3 4 6 8 9 10], 검증데이터 : [5 7] 훈련데이터:[ 2 3 4 5 6 7 8 10], 검증데이터 : [1 9] 훈련데이터:[ 1 2 3 5 7 8 9 10], 검증데이터 : [4 6] 훈련데이터:[1 2 4 5 6 7 8 9], 검증데이터 : [ 3 10] 훈련데이터:[ 1 3 4 5 6 7 9 10], 검증데이터 : [2 8] 교차 검증 함수 1234from sklearn.model_selection import cross_validatescores = cross_validate(dt, train_input, train_target)print(scores)print(&quot;평균:&quot;, np.mean(scores['test_score'])) {'fit_time': array([0.0087018 , 0.00587964, 0.00602317, 0.00796366, 0.00969625]), 'score_time': array([0.00056958, 0.0004859 , 0.00047922, 0.00093341, 0.00075316]), 'test_score': array([0.86923077, 0.84615385, 0.87680462, 0.84889317, 0.83541867])} 평균: 0.855300214703487 StratifiedKFold사 12345from sklearn.model_selection import StratifiedKFoldsplitter = StratifiedKFold(n_splits = 10, shuffle=True, random_state=42)scores = cross_validate(dt, train_input, train_target, cv=StratifiedKFold())print(scores)print(&quot;평균:&quot;, np.mean(scores['test_score'])) {'fit_time': array([0.02411795, 0.01521921, 0.01986766, 0.02518582, 0.01562715]), 'score_time': array([0.00103855, 0.00100446, 0.00081253, 0.00088406, 0.0007534 ]), 'test_score': array([0.86923077, 0.84615385, 0.87680462, 0.84889317, 0.83541867])} 평균: 0.855300214703487 하이퍼 파라미터 튜닝 그리드 서치 사람이 수동적으로 입력하는 것. max_depth로 할 때 : [1,3,7] 랜덤 서치 사람이 범위만 정해준다. amx_depth : 1 ~ 10 사이 / by random 베이지안 옵티마이제이션 AutoML = 사람의 개입 없이 하이퍼파라미터 튜닝을 자동으로 수행하는 기술 예) Pycaret, 각 모델마다 적게는 1,2개 이고 많게는 5,6개의 매개변수를 제공. XGBoost 100개…??????!?!?!?!?!??! 하이퍼파라미터와 동시에 교차검증을 수행 미친짓..!!!! 교차검증 5번 교차 검증 1번 돌 때, Max Depth 3번 적용 총 결괏값 = 3 x 5 x 2 Max Dept = 1, 3, 7 Criterion = gini, entropy 1234567891011from sklearn.model_selection import GridSearchCVparams = { 'min_impurity_decrease' : [0.0001, 0.0002, 0.0003, 0.0004, 0.0004], 'max_depth': [1,3,7], 'criterion': ['gini','entropy']}gs = GridSearchCV(DecisionTreeClassifier(random_state=42), params,n_jobs=-1)gs.fit(train_input, train_target) GridSearchCV(estimator=DecisionTreeClassifier(random_state=42), n_jobs=-1, param_grid={'criterion': ['gini', 'entropy'], 'max_depth': [1, 3, 7], 'min_impurity_decrease': [0.0001, 0.0002, 0.0003, 0.0004, 0.0004]}) 12print(&quot;best:&quot;,gs.best_estimator_)dt = gs.best_estimator_ best: DecisionTreeClassifier(criterion='entropy', max_depth=7, min_impurity_decrease=0.0004, random_state=42)","link":"/2022/07/04/day0704/"},{"title":"practise_1","text":"가나다 라마바사 아자 차카 타 파 하","link":"/2022/06/30/practise_1/"},{"title":"practise_3","text":"1safbiuq3lwjkanefo4u3ehfinldsjkmjrhnfueijk werewrqwerwe sdfdsfdsafasf 1#################3","link":"/2022/06/30/practise_3/"},{"title":"0701_ml_assignment","text":"2.3. Object Creration - 객체 생성4. Viewing Data - 데이터 확인하기5. Selection - 선택6. Missing Data - 결측치7. Operation - 연산8. Merge - 병합9. Grouping - 그룹화10. Reshaping - 변형11. Time Series - 시계열12. Categoricals - 범주화13. Plotting - 그래프14. Getting Data In / Out - 데이터 입/출력15. Gotchas - 잡았다 !!!!!!! 일반적으로 각 패키지는 pd, np, plt 라는 이름으로 불러온다. 123import pandas as pdimport numpy as npimport matplotlib.pyplot as plt Objesct Creation 객체 생성 pandas는 값을 가지고 있는 리스트를 통해 series를 만들고, 정수로 만들어진 인덱스를 기본값으로 불러올 것이다. 12s = pd.Series([1,3,5,np.nan,6,8]) # 대분자 S / 소.대문자 구분 ;s 0 1.0 1 3.0 2 5.0 3 NaN 4 6.0 5 8.0 dtype: float64 datetime 인덱스 &amp; 레이블이 있는 열을 가지고 있는 numpy 배열을 전달하여 df을 만든다. 12dates = pd.date_range('20130101',periods=6)dates DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D') 123df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))df# 실행할 때마다 수치가 바뀐다. - ramdom .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 1.150838 -0.213697 -0.726230 -0.773061 2013-01-02 0.088406 -0.562989 0.601221 -0.810315 2013-01-03 -0.179790 0.108052 -0.846862 0.483234 2013-01-04 -0.782275 -0.593990 3.207679 1.775594 2013-01-05 0.874199 -0.188589 0.054599 -0.101458 2013-01-06 -1.664181 -0.778895 -0.222032 0.000041 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-56c6714f-88df-4005-a04a-718b47d8f83b button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-56c6714f-88df-4005-a04a-718b47d8f83b'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Series 같은 것으로 변환될 수 있는 객체들의 dict로 구성된 데이터 프레임을 만듭니다. 1234567df2 = pd.DataFrame({'A':1., 'B' : pd.Timestamp('20130102'), 'C' : pd.Series(1,index=list(range(4)),dtype='float32'), 'D': np.array([3]*4,dtype='int32'), 'E': pd.Categorical([&quot;test&quot;,&quot;train&quot;,&quot;test&quot;,&quot;train&quot;]), 'F' : 'foo'})df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 1.150838 -0.213697 -0.726230 -0.773061 2013-01-02 0.088406 -0.562989 0.601221 -0.810315 2013-01-03 -0.179790 0.108052 -0.846862 0.483234 2013-01-04 -0.782275 -0.593990 3.207679 1.775594 2013-01-05 0.874199 -0.188589 0.054599 -0.101458 2013-01-06 -1.664181 -0.778895 -0.222032 0.000041 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-945e38a1-ef50-410f-a454-b607cf7b9846 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-945e38a1-ef50-410f-a454-b607cf7b9846'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df2. dtypes A float64 B datetime64[ns] C float32 D int32 E category F object dtype: object 1# df2. &lt;TAB&gt; 2. Viewing DAta (데이터 확인하기) 데이터 프레임의 가장 윗 줄과 마지막 줄을 확인하고 싶을 때에 사용하는 방법으로 df.tail() 와 df.head() 가 있따. 괄호 안에 숫자가 있으면 그 수치만큼, 없으면 디폴트로 5다. 1df.head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 1.150838 -0.213697 -0.726230 -0.773061 2013-01-02 0.088406 -0.562989 0.601221 -0.810315 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-554eb675-9aec-4a41-9d71-59f9218f18c1 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-554eb675-9aec-4a41-9d71-59f9218f18c1'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.head(6) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 1.150838 -0.213697 -0.726230 -0.773061 2013-01-02 0.088406 -0.562989 0.601221 -0.810315 2013-01-03 -0.179790 0.108052 -0.846862 0.483234 2013-01-04 -0.782275 -0.593990 3.207679 1.775594 2013-01-05 0.874199 -0.188589 0.054599 -0.101458 2013-01-06 -1.664181 -0.778895 -0.222032 0.000041 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-b55d2f57-33cf-45f7-b843-c4729d811f00 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-b55d2f57-33cf-45f7-b843-c4729d811f00'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 인덱스index, 열column 그리고 넘파이 numpy 데이터에 대한 세부 정보를 보자. 1df.index DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D') 1df.columns Index(['A', 'B', 'C', 'D'], dtype='object') 1df.values array([[ 1.15083777e+00, -2.13697486e-01, -7.26230025e-01, -7.73061488e-01], [ 8.84064815e-02, -5.62989014e-01, 6.01221288e-01, -8.10315398e-01], [-1.79789511e-01, 1.08051907e-01, -8.46862448e-01, 4.83233668e-01], [-7.82275244e-01, -5.93989684e-01, 3.20767926e+00, 1.77559399e+00], [ 8.74198562e-01, -1.88589347e-01, 5.45985731e-02, -1.01458158e-01], [-1.66418093e+00, -7.78894788e-01, -2.22031961e-01, 4.09616212e-05]]) 12df.describe()#이게 개꿀이네 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D count 6.000000 6.000000 6.000000 6.000000 mean -0.085467 -0.371685 0.344729 0.095672 std 1.045602 0.328776 1.498967 0.958734 min -1.664181 -0.778895 -0.846862 -0.810315 25% -0.631654 -0.586240 -0.600181 -0.605161 50% -0.045692 -0.388343 -0.083717 -0.050709 75% 0.677751 -0.194866 0.464566 0.362435 max 1.150838 0.108052 3.207679 1.775594 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-250de777-4e7c-4976-b627-8c19db6154c5 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-250de777-4e7c-4976-b627-8c19db6154c5'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123df.T# 데이터를 전치한다는데# 전치란? 행/열 --&gt; 열/행 으로 바꾸는 작업. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 2013-01-01 2013-01-02 2013-01-03 2013-01-04 2013-01-05 2013-01-06 A 1.150838 0.088406 -0.179790 -0.782275 0.874199 -1.664181 B -0.213697 -0.562989 0.108052 -0.593990 -0.188589 -0.778895 C -0.726230 0.601221 -0.846862 3.207679 0.054599 -0.222032 D -0.773061 -0.810315 0.483234 1.775594 -0.101458 0.000041 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-713998d3-d39b-4dde-9b04-bab2a57023a0 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-713998d3-d39b-4dde-9b04-bab2a57023a0'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.sort_index(axis=1, ascending=False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } D C B A 2013-01-01 -0.773061 -0.726230 -0.213697 1.150838 2013-01-02 -0.810315 0.601221 -0.562989 0.088406 2013-01-03 0.483234 -0.846862 0.108052 -0.179790 2013-01-04 1.775594 3.207679 -0.593990 -0.782275 2013-01-05 -0.101458 0.054599 -0.188589 0.874199 2013-01-06 0.000041 -0.222032 -0.778895 -1.664181 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8bddd13b-6f8b-4b2a-a379-7d7485b74a4f button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8bddd13b-6f8b-4b2a-a379-7d7485b74a4f'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 값 별로 정렬한다. 1df.sort_values(by='B') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-06 -1.664181 -0.778895 -0.222032 0.000041 2013-01-04 -0.782275 -0.593990 3.207679 1.775594 2013-01-02 0.088406 -0.562989 0.601221 -0.810315 2013-01-01 1.150838 -0.213697 -0.726230 -0.773061 2013-01-05 0.874199 -0.188589 0.054599 -0.101458 2013-01-03 -0.179790 0.108052 -0.846862 0.483234 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-f9bfd09c-db05-4fa4-88ad-e842e158231e button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-f9bfd09c-db05-4fa4-88ad-e842e158231e'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Selecetion ( 선택 ) Pansdas에 최적화된 데이터 접근 방법으로 = .at, .iat, .loc 및 .iloc을 추천한다. Getting ( 데이터 얻기 ) df.A 와 동일한 Series를 생성하는 단일 열을 선택한다. 12#@title 기본 제목 텍스트df['A'] 2013-01-01 1.150838 2013-01-02 0.088406 2013-01-03 -0.179790 2013-01-04 -0.782275 2013-01-05 0.874199 2013-01-06 -1.664181 Freq: D, Name: A, dtype: float64 1df[0:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 1.150838 -0.213697 -0.726230 -0.773061 2013-01-02 0.088406 -0.562989 0.601221 -0.810315 2013-01-03 -0.179790 0.108052 -0.846862 0.483234 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-5568f734-2c61-4fdb-a406-ec367bf65cbc button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-5568f734-2c61-4fdb-a406-ec367bf65cbc'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df['20130102': '20130104'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-02 0.088406 -0.562989 0.601221 -0.810315 2013-01-03 -0.179790 0.108052 -0.846862 0.483234 2013-01-04 -0.782275 -0.593990 3.207679 1.775594 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-4bea89ca-cc2f-438f-9e25-989546811fdf button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-4bea89ca-cc2f-438f-9e25-989546811fdf'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.loc[dates[3]] A -0.782275 B -0.593990 C 3.207679 D 1.775594 Name: 2013-01-04 00:00:00, dtype: float64 12df.loc['20130102': '20130106', ['A','B','D']]# df.loc['행으로 어디부터 어디까지', [열 어디부터어디까지 혹은 열 몇개만.(column)]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B D 2013-01-02 0.088406 -0.562989 -0.810315 2013-01-03 -0.179790 0.108052 0.483234 2013-01-04 -0.782275 -0.593990 1.775594 2013-01-05 0.874199 -0.188589 -0.101458 2013-01-06 -1.664181 -0.778895 0.000041 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-901d3494-de67-400e-b4df-d3a116480d48 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-901d3494-de67-400e-b4df-d3a116480d48'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.loc[dates[0],['A','B']] A 1.150838 B -0.213697 Name: 2013-01-01 00:00:00, dtype: float64 1df.loc[dates[0],'A'] 1.150837768099418 1df.at[dates[0],'A'] 1.150837768099418 Selection by Position 위치로 선택하기 1df.iloc[3] A -0.782275 B -0.593990 C 3.207679 D 1.775594 Name: 2013-01-04 00:00:00, dtype: float64 정수로 표기된 슬라이스들을 통해, nimpy, pythin과 유사하게 작동한당 12df.iloc[3:5, 0:2]# index number로 하기 때문에 4일 데이터부터 나온다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2013-01-04 -0.782275 -0.593990 2013-01-05 0.874199 -0.188589 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-da1f981c-3af8-4d0a-aa61-463d25171b94 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-da1f981c-3af8-4d0a-aa61-463d25171b94'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 명시적으로 행을 나누고자 하는 경우도 있겠쥬. 123df.iloc[1:3,:]# 행 index 1부터 3까지, 전체# 반대로도 할 수 있겠지? .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-02 0.088406 -0.562989 0.601221 -0.810315 2013-01-03 -0.179790 0.108052 -0.846862 0.483234 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8e46623d-4d4c-4802-bf14-03ff2d89511a button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8e46623d-4d4c-4802-bf14-03ff2d89511a'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Boolean Indexing 데이터를 선택하기 위해 단일 열의 값을 사용한다. 1df[df.A&gt;0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 1.150838 -0.213697 -0.726230 -0.773061 2013-01-02 0.088406 -0.562989 0.601221 -0.810315 2013-01-05 0.874199 -0.188589 0.054599 -0.101458 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-ef8f353c-e4d4-4eee-815c-a7eb000ecef6 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-ef8f353c-e4d4-4eee-815c-a7eb000ecef6'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 12df[A&gt;0]## 이렇게는 왜 안되는 것이지?? --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-29-42bbaff3506d&gt; in &lt;module&gt;() ----&gt; 1 df[A&gt;0] 2 ## 이렇게는 왜 안되는 것이지?? NameError: name 'A' is not defined 1df[df&gt;0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 1.150838 NaN NaN NaN 2013-01-02 0.088406 NaN 0.601221 NaN 2013-01-03 NaN 0.108052 NaN 0.483234 2013-01-04 NaN NaN 3.207679 1.775594 2013-01-05 0.874199 NaN 0.054599 NaN 2013-01-06 NaN NaN NaN 0.000041 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-dcd37700-796c-4e35-a228-14da54bb0cea button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-dcd37700-796c-4e35-a228-14da54bb0cea'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 필터링을 위한 method isin()을 사용한다. 123df2 = df.copy()df2['E'] = ['one', 'two','three', ' four','three','one']df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 2013-01-01 1.150838 -0.213697 -0.726230 -0.773061 one 2013-01-02 0.088406 -0.562989 0.601221 -0.810315 two 2013-01-03 -0.179790 0.108052 -0.846862 0.483234 three 2013-01-04 -0.782275 -0.593990 3.207679 1.775594 four 2013-01-05 0.874199 -0.188589 0.054599 -0.101458 three 2013-01-06 -1.664181 -0.778895 -0.222032 0.000041 one &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-6bb597e6-7ee2-4218-8f62-8b9bb6526ce7 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-6bb597e6-7ee2-4218-8f62-8b9bb6526ce7'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df2[df2['E'].isin(['two','four'])] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 2013-01-02 0.088406 -0.562989 0.601221 -0.810315 two &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-1047106e-7810-4fe7-825d-2705ace69786 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-1047106e-7810-4fe7-825d-2705ace69786'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Setting(설정) 새 열을 설정하면 데이터가 인덱스 별로 자동 정렬됩니다. 12s1 = pd.Series([1,2,3,4,5,6],index=pd.date_range('20130102',periods=6))s1 2013-01-02 1 2013-01-03 2 2013-01-04 3 2013-01-05 4 2013-01-06 5 2013-01-07 6 Freq: D, dtype: int64 12df['F']=s1s1 2013-01-02 1 2013-01-03 2 2013-01-04 3 2013-01-05 4 2013-01-06 5 2013-01-07 6 Freq: D, dtype: int64 123df.at[dates[0],'A']=0df.iat[0,1]= 0# 이건 왜 하는거지 12df.loc[:,'D']=np.array([5]*len(df))df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 0.000000 0.000000 -0.726230 5 NaN 2013-01-02 0.088406 -0.562989 0.601221 5 1.0 2013-01-03 -0.179790 0.108052 -0.846862 5 2.0 2013-01-04 -0.782275 -0.593990 3.207679 5 3.0 2013-01-05 0.874199 -0.188589 0.054599 5 4.0 2013-01-06 -1.664181 -0.778895 -0.222032 5 5.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-0a3e486f-d507-40d8-bd30-e0b9bc9c4381 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-0a3e486f-d507-40d8-bd30-e0b9bc9c4381'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; where 연산을 설정한 123df2 = df.copy()df2[df2&gt;0]= -df2df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 0.000000 0.000000 -0.726230 -5 NaN 2013-01-02 -0.088406 -0.562989 -0.601221 -5 -1.0 2013-01-03 -0.179790 -0.108052 -0.846862 -5 -2.0 2013-01-04 -0.782275 -0.593990 -3.207679 -5 -3.0 2013-01-05 -0.874199 -0.188589 -0.054599 -5 -4.0 2013-01-06 -1.664181 -0.778895 -0.222032 -5 -5.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-7b03d81f-3a8b-4f26-a402-4bc31f6b8d7b button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-7b03d81f-3a8b-4f26-a402-4bc31f6b8d7b'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 4. Missing Data( 결측치 ) Pandas는 결측치를 표현하기 위해 주로 np.nan값을 사용한다. 이 방법은 기본 설정값이지만 계산에서 포함되지 않는다. Reindexing으로 지정된 축 상의 인덱스를 변경/ 추가/삭제할 수 있다. Reindexing은 데이터의 복사본을 반환한다. 123df1 = df.reindex(index=dates[0:4],columns=list(df.columns)+['E'])df1.loc[dates[0]:dates[1],'E']=1df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-01 0.000000 0.000000 -0.726230 5 NaN 1.0 2013-01-02 0.088406 -0.562989 0.601221 5 1.0 1.0 2013-01-03 -0.179790 0.108052 -0.846862 5 2.0 NaN 2013-01-04 -0.782275 -0.593990 3.207679 5 3.0 NaN &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-4b900455-3f10-4277-a97b-b934dd625a95 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-4b900455-3f10-4277-a97b-b934dd625a95'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 결측치를 가지고 있는 행들을 지운다. // 결측치(=Missing Data) 1df1.dropna(how='any') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-02 0.088406 -0.562989 0.601221 5 1.0 1.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-0496cc97-b2c6-45e9-8541-b121ea5f59a0 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-0496cc97-b2c6-45e9-8541-b121ea5f59a0'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 결측치를 채워 넣는다. 1df1.fillna(value=5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-01 0.000000 0.000000 -0.726230 5 5.0 1.0 2013-01-02 0.088406 -0.562989 0.601221 5 1.0 1.0 2013-01-03 -0.179790 0.108052 -0.846862 5 2.0 5.0 2013-01-04 -0.782275 -0.593990 3.207679 5 3.0 5.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-18083257-01ab-44df-9759-105511ffbc13 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-18083257-01ab-44df-9759-105511ffbc13'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; nan인 값에 boolean을 통한 표식을 얻는다. 데이터 프레임의 모든값이 boolean형태로 표시되도록 하며, nan인 에만 True가 표시되게 하는 함수이다. 1pd.isna(df1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-01 False False False False True False 2013-01-02 False False False False False False 2013-01-03 False False False False False True 2013-01-04 False False False False False True &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-80777abf-6167-4704-b4de-e3ffd415392b button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-80777abf-6167-4704-b4de-e3ffd415392b'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Operation (연산) 이진 (Binary) 연산의 기본 섹션을 참조하셈 Stats(통계) 일반적으로 결츠기를 제외한 후 연산된다. 기술 통계를 수행한다. 1df.mean() A -0.277273 B -0.336068 C 0.344729 D 5.000000 F 3.000000 dtype: float64 다른 축에서 동일한 연산을 수행한다. 1df.mean(1) 2013-01-01 1.068442 2013-01-02 1.225328 2013-01-03 1.216280 2013-01-04 1.966283 2013-01-05 1.948042 2013-01-06 1.466978 Freq: D, dtype: float64 정렬이 필요하며, 차원이 다른 객체로 연산해보겠다. 또한, pandas는 지정된 차원을 따라 자동으로 브로드 캐스팅 된다. broadcast란, numpy에서 유래한 용어로, n차이나 스칼라값으로 연산ㅇ르 수행할 떄 도출되는 결과의 규칙을 설명하는 것을 의미한당 12s = pd.Series([1,3,5,np.nan,6,8],index=dates).shift(2)s 2013-01-01 NaN 2013-01-02 NaN 2013-01-03 1.0 2013-01-04 3.0 2013-01-05 5.0 2013-01-06 NaN Freq: D, dtype: float64 1df.sub(s, axis='index') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 NaN NaN NaN NaN NaN 2013-01-02 NaN NaN NaN NaN NaN 2013-01-03 -1.179790 -0.891948 -1.846862 4.0 1.0 2013-01-04 -3.782275 -3.593990 0.207679 2.0 0.0 2013-01-05 -4.125801 -5.188589 -4.945401 0.0 -1.0 2013-01-06 NaN NaN NaN NaN NaN &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-ceb5ec9b-eefc-4c00-8356-060a99b5c45e button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-ceb5ec9b-eefc-4c00-8356-060a99b5c45e'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Apply 적용 데이터에 함수를 적용한다. 1df.apply(np.cumsum) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 0.000000 0.000000 -0.726230 5 NaN 2013-01-02 0.088406 -0.562989 -0.125009 10 1.0 2013-01-03 -0.091383 -0.454937 -0.971871 15 3.0 2013-01-04 -0.873658 -1.048927 2.235808 20 6.0 2013-01-05 0.000540 -1.237516 2.290407 25 10.0 2013-01-06 -1.663641 -2.016411 2.068375 30 15.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-be323473-e41e-4f97-97da-458f2a14ce91 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-be323473-e41e-4f97-97da-458f2a14ce91'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.apply(lambda x : x.max()- x.min()) A 2.538379 B 0.886947 C 4.054542 D 0.000000 F 4.000000 dtype: float64 Histogramming(히스토그래밍) 12s = pd.Series(np.random.randint(0,7,size=10))s 0 6 1 2 2 1 3 5 4 5 5 4 6 0 7 6 8 1 9 2 dtype: int64 1s.value_counts() 6 2 2 2 1 2 5 2 4 1 0 1 dtype: int64 1s.value_counts() 6 2 2 2 1 2 5 2 4 1 0 1 dtype: int64 String Methods ( 문자열 메소드 ) series는 다음의 코드와 같이 문자열 처리 메소드 모듬 (set)을 가지고 있다. 이 모음은 배열의 각 요소를 쉽게 조작할 수 있도록 만들어주는 문자열의 속성에 포항되어 있따. 문자열의 패턴 일치 확인은 기본적으로 정규 표현식으롤 사용하며, 몇몇 경우에는 항상 정규 표현식을 사용함에 으ㅠ의하자. 123s = pd.Series(['A','B','C','Aaba', 'Baca', np.nan,'CABA', 'dog','cat']) s.str.lower() 0 a 1 b 2 c 3 aaba 4 baca 5 NaN 6 caba 7 dog 8 cat dtype: object Merge 병합 concat 연결 결합(join)/ 병합(merge) 형태의 연산에 대한 인덱스, 관계 대수 기능을 위한 다양한 형태의논리를 포함한 Series, 데이터 프레임, Panel객체를 손쉽게 결합할 수 있도록 하는 다양한 기능을pandas에서 제공한다. concat()으로 pandas객체를 연결한다. 12df = pd.DataFrame(np.random.randn(10,4))df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 0 0.454810 0.017449 0.558524 0.601674 1 0.766934 0.876279 -0.785546 0.710571 2 0.567396 2.066313 -0.339889 2.944188 3 -0.338279 -1.939238 -0.852469 -0.217860 4 0.317339 -0.374266 -0.258369 -1.957459 5 -1.477248 0.303326 1.977440 0.872459 6 -0.222192 -0.610586 -2.076449 -0.435316 7 -1.603901 -0.325204 0.035246 0.960440 8 -0.475209 1.675653 -1.438185 1.316810 9 -0.132703 -1.080558 0.391828 -0.328518 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-9881c514-c382-4bc8-bf97-8d9c6fd4f397 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-9881c514-c382-4bc8-bf97-8d9c6fd4f397'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123# break it into peicespieces = [df[:3],df[3:7], df[7:]]pd.concat(pieces) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 0 0.454810 0.017449 0.558524 0.601674 1 0.766934 0.876279 -0.785546 0.710571 2 0.567396 2.066313 -0.339889 2.944188 3 -0.338279 -1.939238 -0.852469 -0.217860 4 0.317339 -0.374266 -0.258369 -1.957459 5 -1.477248 0.303326 1.977440 0.872459 6 -0.222192 -0.610586 -2.076449 -0.435316 7 -1.603901 -0.325204 0.035246 0.960440 8 -0.475209 1.675653 -1.438185 1.316810 9 -0.132703 -1.080558 0.391828 -0.328518 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-62d7bd0f-92de-4b5f-b50e-5ea1d5e3d7e0 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-62d7bd0f-92de-4b5f-b50e-5ea1d5e3d7e0'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Join SQL 방식으로 병합한다. 123left = pd.DataFrame({'keys':['foo','foo'],'lval':[1,2]})right = pd.DataFrame({'keys':['foo','foo'],'rval':[4,5]}) 1left .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } keys lval 0 foo 1 1 foo 2 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-1bd6e673-51f6-4e88-b864-ec0ae7ab2ea9 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-1bd6e673-51f6-4e88-b864-ec0ae7ab2ea9'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1right .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } keys rval 0 foo 4 1 foo 5 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-afe54507-8c07-47c4-a3b8-14dad2873546 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-afe54507-8c07-47c4-a3b8-14dad2873546'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123pd.merge(left, right, on= 'key')# 오타 없는데 왜 안 되 는 것 이 야 --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-57-2c9f5279fab3&gt; in &lt;module&gt;() ----&gt; 1 pd.merge(left, right, on= 'key') 2 3 # 오타 없는데 왜 안 되 는 것 이 야 /usr/local/lib/python3.7/dist-packages/pandas/core/reshape/merge.py in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate) 117 copy=copy, 118 indicator=indicator, --&gt; 119 validate=validate, 120 ) 121 return op.get_result() /usr/local/lib/python3.7/dist-packages/pandas/core/reshape/merge.py in __init__(self, left, right, how, on, left_on, right_on, axis, left_index, right_index, sort, suffixes, copy, indicator, validate) 697 self.right_join_keys, 698 self.join_names, --&gt; 699 ) = self._get_merge_keys() 700 701 # validate the merge keys dtypes. We may need to coerce /usr/local/lib/python3.7/dist-packages/pandas/core/reshape/merge.py in _get_merge_keys(self) 1094 if not is_rkey(rk): 1095 if rk is not None: -&gt; 1096 right_keys.append(right._get_label_or_level_values(rk)) 1097 else: 1098 # work-around for merge_asof(right_index=True) /usr/local/lib/python3.7/dist-packages/pandas/core/generic.py in _get_label_or_level_values(self, key, axis) 1777 values = self.axes[axis].get_level_values(key)._values 1778 else: -&gt; 1779 raise KeyError(key) 1780 1781 # Check for duplicates KeyError: 'key' 123left = pd.DataFrame({'key':['foo','bar'],'lval':[1,2]})right = pd.DataFrame({'key':['foo','bar'],'rval':[4,5]}) 1left .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lval 0 foo 1 1 bar 2 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8a3e4b79-5dfa-4688-a996-bd6d20ba40d9 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8a3e4b79-5dfa-4688-a996-bd6d20ba40d9'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1right .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key rval 0 foo 4 1 bar 5 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-f1434b14-5172-44f2-b77d-8c003e4dfc4a button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-f1434b14-5172-44f2-b77d-8c003e4dfc4a'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 12pd.merge(left, right, on= 'key')# 이건 되는데 위에건 왜 안되지 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lval rval 0 foo 1 4 1 bar 2 5 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-e4c827d5-c9aa-4966-9367-8c294fb72198 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-e4c827d5-c9aa-4966-9367-8c294fb72198'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Append (추가) 12df = pd.DataFrame(np.random.randn(8,4),columns=['A','B','C','D'])df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 0.823210 0.246895 0.913281 -1.660168 1 1.979847 -2.856473 0.318576 -0.973824 2 0.939356 -0.218424 -0.885960 2.558463 3 -0.886669 -0.886446 0.339713 -0.398010 4 -0.139478 -0.644103 0.396378 -0.718140 5 -0.362182 -0.097130 0.346834 0.202235 6 -0.658215 -1.206936 0.531376 -0.483913 7 0.240862 0.895250 0.963120 -0.332216 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8ba73855-f9d6-4905-abd4-0948f31b52c7 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8ba73855-f9d6-4905-abd4-0948f31b52c7'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 12s = df.iloc[3]df.append(s,ignore_index=True) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 0.823210 0.246895 0.913281 -1.660168 1 1.979847 -2.856473 0.318576 -0.973824 2 0.939356 -0.218424 -0.885960 2.558463 3 -0.886669 -0.886446 0.339713 -0.398010 4 -0.139478 -0.644103 0.396378 -0.718140 5 -0.362182 -0.097130 0.346834 0.202235 6 -0.658215 -1.206936 0.531376 -0.483913 7 0.240862 0.895250 0.963120 -0.332216 8 -0.886669 -0.886446 0.339713 -0.398010 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8f936aa2-1b32-417a-9350-9299ed57ddd8 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8f936aa2-1b32-417a-9350-9299ed57ddd8'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 7. Grouping 그룹화 그룹화는 다음 단계 중 하나 이상을 포함하는 과정을 가리킨다. 몇몇 기준에 ㄸ라 여러 그룹으로 데이터를 분할 각 그룹에 독립적으로 함수를 적용 결과물들ㅇ르 하나의 데이터 구조로 결 123456789df = pd.DataFrame( { 'A' : ['foo','bar','foo', 'bar','foo','bar','foo','foo'], 'B' : ['one','one','tow', 'three','two', 'two', 'one','three'], 'C' : np.random.randn(8), 'D' : np.random.randn(8) })df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 foo one 0.997375 1.882029 1 bar one -0.138304 0.114996 2 foo tow 0.188913 -1.267636 3 bar three 0.930161 -0.632197 4 foo two -0.304023 0.154579 5 bar two -0.059475 0.072608 6 foo one 0.660924 0.026095 7 foo three -0.466455 -0.731099 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-595f65bc-500a-4c41-b605-bf1f71c8f861 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-595f65bc-500a-4c41-b605-bf1f71c8f861'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 생선된 데이터프레임을 그룹화한 후 각 그룹에 sum()함수를 적용한다. 1df.groupby('A').sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C D A bar 0.732382 -0.444593 foo 1.076734 0.063968 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-afb519ab-0f69-4781-aa12-643964f03509 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-afb519ab-0f69-4781-aa12-643964f03509'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 여러 열을 기준으로 그룹화하면 계층적 인덱스가 형성된다. 여기에도 sum하수를 적용할 수 있다. 1df.groupby(['A','B']).sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C D A B bar one -0.138304 0.114996 three 0.930161 -0.632197 two -0.059475 0.072608 foo one 1.658298 1.908124 three -0.466455 -0.731099 tow 0.188913 -1.267636 two -0.304023 0.154579 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-0812a57f-7515-405d-bb52-056acb1ed017 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-0812a57f-7515-405d-bb52-056acb1ed017'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 8. Reshaping 변 Stack 스택 12345tuples = list(zip(*[['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], ['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two']])) 1234index = pd.MultiIndex.from_tuples(tuples, names=['first','second'])dfd = pd.DataFrame(np.random.randn(8,2),index=index,columns=['A','B'])df2 = df[:4]df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 foo one 0.997375 1.882029 1 bar one -0.138304 0.114996 2 foo tow 0.188913 -1.267636 3 bar three 0.930161 -0.632197 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-4ec42872-8a4e-4921-91d2-2a94ad90099c button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-4ec42872-8a4e-4921-91d2-2a94ad90099c'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; stack() 메소드는 데이터프레임 열들의 계층으 ㄹ”압축” 한다. 12stacked = df2.stack()stacked 0 A foo B one C 0.997375 D 1.882029 1 A bar B one C -0.138304 D 0.114996 2 A foo B tow C 0.188913 D -1.267636 3 A bar B three C 0.930161 D -0.632197 dtype: object “stack된” 데이터 프레임 또는 Series인 경우 , stack()의 역 연산은 unstack()이며 기본적ㅇ로 마지막 계층을 unstack한다. 1stacked.unstack() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 foo one 0.997375 1.882029 1 bar one -0.138304 0.114996 2 foo tow 0.188913 -1.267636 3 bar three 0.930161 -0.632197 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-32ddb2f9-eb93-49b4-9ca3-b4c19cebe35e button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-32ddb2f9-eb93-49b4-9ca3-b4c19cebe35e'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1stacked.unstack(1) 1stacked.unstack(0) Pivot Tables(피봇 테이블) 123456df = pd.DataFrame({'A' : ['one', 'one', 'two', 'three'] * 3, 'B' : ['A', 'B', 'C'] * 4, 'C' : ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'] * 2, 'D' : np.random.randn(12), 'E' : np.random.randn(12)})df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 0 one A foo 1.664422 1.195650 1 one B foo -1.395872 2.771247 2 two C foo -1.573829 -0.173787 3 three A bar 0.001164 1.494723 4 one B bar 1.648831 1.723048 5 one C bar 0.505952 -0.493276 6 two A foo -0.140686 0.028681 7 three B foo -0.832587 -0.834539 8 one C foo 0.568715 -1.518473 9 one A bar -0.051618 -2.724911 10 two B bar 0.992833 -1.368982 11 three C bar 0.139253 0.794720 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-ed7944fa-fe89-476b-bfdb-3b802645e749 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-ed7944fa-fe89-476b-bfdb-3b802645e749'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 이 데이터로부터 피봇 테이블을 매우 쉽게 생성할 수 있다. 1pd.pivot_table(df, values='D', index=['A','B'],columns=['C']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C bar foo A B one A -0.051618 1.664422 B 1.648831 -1.395872 C 0.505952 0.568715 three A 0.001164 NaN B NaN -0.832587 C 0.139253 NaN two A NaN -0.140686 B 0.992833 NaN C NaN -1.573829 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-c82b58fd-f532-483c-ae85-20b0f9abc45e button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-c82b58fd-f532-483c-ae85-20b0f9abc45e'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 9. Time Series (시계열) pandas는 자주 일어나는 변환 사이에 수행하는 리샘플링 연산을 위한 간닫ㄴ하고, 강력하며, 효율적인 함수르 ㄹ제공합니다., 이는 재무 응용에서 매우 일반적이지만 이에 국한되지는 않습니다. 123rng = pd.date_range('1/1/2012', periods=100,freq='S')ts = pd.Series(np.random.randint(0,500,len(rng)), index=rng)ts.resample('5Min').sum() 2012-01-01 27177 Freq: 5T, dtype: int64 시간대를 표현한다. 123rng = pd.date_range('3/6/2012 00:00',periods=5, freq='D')ts = pd.Series(np.random.randn(len(rng)),rng)ts 2012-03-06 -1.020470 2012-03-07 -0.252398 2012-03-08 0.293259 2012-03-09 0.907334 2012-03-10 -2.033588 Freq: D, dtype: float64 12ts_utc = ts.tz_localize('UTC')ts_utc 2012-03-06 00:00:00+00:00 -1.020470 2012-03-07 00:00:00+00:00 -0.252398 2012-03-08 00:00:00+00:00 0.293259 2012-03-09 00:00:00+00:00 0.907334 2012-03-10 00:00:00+00:00 -2.033588 Freq: D, dtype: float64 시간 표현 &lt;-&gt; 기간 표현으로 변환해보자! 123rng = pd.date_range('1/1/2012', periods=5,freq='M')ts = pd.Series(np.random.randn(len(rng)),index=rng)ts 2012-01-31 1.072416 2012-02-29 -0.907574 2012-03-31 -0.324011 2012-04-30 -1.333044 2012-05-31 -1.228033 Freq: M, dtype: float64 12ps = ts.to_period()ps 2012-01 1.072416 2012-02 -0.907574 2012-03 -0.324011 2012-04 -1.333044 2012-05 -1.228033 Freq: M, dtype: float64 1ps.to_timestamp() 2012-01-01 1.072416 2012-02-01 -0.907574 2012-03-01 -0.324011 2012-04-01 -1.333044 2012-05-01 -1.228033 Freq: MS, dtype: float64 기간 &lt;-&gt; 시간 변환은 편리한 산술 기능들을 사용할 수 있도록 해준다. 우리는 11월에 끝나는 연말 결산의 분기별 빈도를 분기말 익월의 월말일 오전 9시로 변환한다. 12345prng = pd.period_range('1990Q1', '2000Q4',freq='Q-NOV')ts = pd.Series(np.random.randn(len(prng)), prng)ts.index = (prng.asfreq('M', 'e') + 1).asfreq('H', 's') + 9ts.head(5)# Q는 Quarter인가보다 1990-03-01 09:00 0.487594 1990-06-01 09:00 -0.139580 1990-09-01 09:00 0.965947 1990-12-01 09:00 -1.198826 1991-03-01 09:00 0.414152 Freq: H, dtype: float64 10. Categoricals(범주화) pandas 는 데이터 프레임 내에 범주형 데이터를 포함할 수 이써 1df = pd.DataFrame({&quot;id&quot;:[1,2,3,4,5,6], &quot;raw_grade&quot;:['a', 'b', 'b', 'a', 'a', 'e']}) 가공하지 않은 성적을 범주형 데이터로 변환. 12df[&quot;grade&quot;] = df[&quot;raw_grade&quot;].astype(&quot;category&quot;)df[&quot;grade&quot;] 0 a 1 b 2 b 3 a 4 a 5 e Name: grade, dtype: category Categories (3, object): ['a', 'b', 'e'] 범주에 더 의미 있는 이름을 붙이기 ( Series.cat.categories로 할당하는 것이 적합 ) 1df[&quot;grade&quot;].catcategories = [&quot;very good&quot;,&quot;good&quot;,&quot;very bad&quot;] 범주의 순서를 바꾸고 동시에 누락된 범주를 추가하기 (Series.cat에 속하는 methods는 기본적으로 새로운 Series를 반환합니다). 1df[&quot;grade&quot;] = df[&quot;grade&quot;].cat.set_categories([&quot;very bad&quot;, &quot;bad&quot;, &quot;medium&quot;, &quot;good&quot;, &quot;very good&quot;]) 1df[&quot;grade&quot;] = df[&quot;grade&quot;].cat.set_categories([&quot;very bad&quot;, &quot;bad&quot;, &quot;medium&quot;, &quot;good&quot;, &quot;very good&quot;]) 123df[&quot;grade&quot;]# 왜 Nan 으로 나오지??? 등급 줘야하는데;;;# 전체 실행 해보자. 0 NaN 1 NaN 2 NaN 3 NaN 4 NaN 5 NaN Name: grade, dtype: category Categories (5, object): ['very bad', 'bad', 'medium', 'good', 'very good'] 정렬은 사전 순서가 아니고 해당 범주에서 지정된 순서대로 배열한다. 1df.sort.values(by=&quot;grade&quot;) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-86-5613d2d3a671&gt; in &lt;module&gt;() ----&gt; 1 df.sort.values(by=&quot;grade&quot;) /usr/local/lib/python3.7/dist-packages/pandas/core/generic.py in __getattr__(self, name) 5485 ): 5486 return self[name] -&gt; 5487 return object.__getattribute__(self, name) 5488 5489 def __setattr__(self, name: str, value) -&gt; None: AttributeError: 'DataFrame' object has no attribute 'sort' 범주의 열을 기준으로 그룹화하면 빈 범주도 표시된다. 1df.groupby(&quot;grade&quot;).size() grade very bad 0 bad 0 medium 0 good 0 very good 0 dtype: int64 Plotting 그래프123ts = pd.Series(np.random.randn(1000), index=pd.date_range('1/1/2000', periods=1000))ts = ts.cumsum()ts.plot() &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f47b7724990&gt; 데이터 프레임에서 plot()메소드는 라벨이 존재하는 모든 열을 그릴떄 좋다. 1234df = pd. DataFrame(np.random.randn(1000,4), index=ts.index, columns=['A','B','C','D'])df = df.cumsum()plt.figure(); df.plot(); plt.legend(loc='best') &lt;matplotlib.legend.Legend at 0x7f47b5120050&gt; &lt;Figure size 432x288 with 0 Axes&gt; 12. Getting Data In / Out (데이터 입/출력) CSV 12df. to_csv('foo.csv')pd.read_csv('foo.csv') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Unnamed: 0 A B C D 0 2000-01-01 -1.313348 0.002810 1.461228 -1.167443 1 2000-01-02 0.184081 -1.126325 0.894431 -0.419294 2 2000-01-03 0.568337 -0.510765 1.461518 -0.565450 3 2000-01-04 0.286196 -0.469588 1.016149 0.910949 4 2000-01-05 0.445462 -2.035244 1.280233 1.337547 ... ... ... ... ... ... 995 2002-09-22 7.319623 27.624494 -37.816135 7.194874 996 2002-09-23 7.045422 27.715441 -38.780685 6.779456 997 2002-09-24 7.564847 30.032305 -39.337411 7.604891 998 2002-09-25 6.295290 32.454797 -39.773601 7.687267 999 2002-09-26 5.206091 31.924824 -40.726880 6.871122 1000 rows × 5 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-92635abf-c2c2-4a82-acc9-25c79d8055b9 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-92635abf-c2c2-4a82-acc9-25c79d8055b9'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; HDF5 HDF5 Store에 쓴다. 1df.to_hdf('foo.h5','df') HDF5 Store에서 읽어온다. 1pd.read_hdf('foo.h5','df') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2000-01-01 -1.313348 0.002810 1.461228 -1.167443 2000-01-02 0.184081 -1.126325 0.894431 -0.419294 2000-01-03 0.568337 -0.510765 1.461518 -0.565450 2000-01-04 0.286196 -0.469588 1.016149 0.910949 2000-01-05 0.445462 -2.035244 1.280233 1.337547 ... ... ... ... ... 2002-09-22 7.319623 27.624494 -37.816135 7.194874 2002-09-23 7.045422 27.715441 -38.780685 6.779456 2002-09-24 7.564847 30.032305 -39.337411 7.604891 2002-09-25 6.295290 32.454797 -39.773601 7.687267 2002-09-26 5.206091 31.924824 -40.726880 6.871122 1000 rows × 4 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-edb5ccb9-ddc6-4166-9c07-124b232c3205 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-edb5ccb9-ddc6-4166-9c07-124b232c3205'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Excel 엑셀 파일에 쓴다. 12df.to_excel('foo.xlsx',sheet_name='sheet1')pd.read_excel('foo.xlsx','sheet1',index_col=None,na_values=['Na']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Unnamed: 0 A B C D 0 2000-01-01 -1.313348 0.002810 1.461228 -1.167443 1 2000-01-02 0.184081 -1.126325 0.894431 -0.419294 2 2000-01-03 0.568337 -0.510765 1.461518 -0.565450 3 2000-01-04 0.286196 -0.469588 1.016149 0.910949 4 2000-01-05 0.445462 -2.035244 1.280233 1.337547 ... ... ... ... ... ... 995 2002-09-22 7.319623 27.624494 -37.816135 7.194874 996 2002-09-23 7.045422 27.715441 -38.780685 6.779456 997 2002-09-24 7.564847 30.032305 -39.337411 7.604891 998 2002-09-25 6.295290 32.454797 -39.773601 7.687267 999 2002-09-26 5.206091 31.924824 -40.726880 6.871122 1000 rows × 5 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-d4a62a39-70bf-4cc1-9f90-bd0547c1986b button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-d4a62a39-70bf-4cc1-9f90-bd0547c1986b'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 13. Gotchas (잡앗더) 연산 수행시 다음과 같은 예외 상황을 볼 수도 있다. 12if pd.Series([False,True,False]): print(&quot;I was True&quot;) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-98-9f5d1e1f60aa&gt; in &lt;module&gt;() ----&gt; 1 if pd.Series([False,True,False]): 2 print(&quot;I was True&quot;) /usr/local/lib/python3.7/dist-packages/pandas/core/generic.py in __nonzero__(self) 1536 def __nonzero__(self): 1537 raise ValueError( -&gt; 1538 f&quot;The truth value of a {type(self).__name__} is ambiguous. &quot; 1539 &quot;Use a.empty, a.bool(), a.item(), a.any() or a.all().&quot; 1540 ) ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all(). 이런 경우 any(),all(),empty() 등을 사용해서 원하는 것을 반영해주어야 한다. 12if pd.Series([False,True,False])is not None: print(&quot;I was True&quot;) I was True","link":"/2022/07/01/day0701_ml_assignment_10MinsToPandas/"},{"title":"day0705_pycaretsample","text":"!pip uninstall sklearn -y!pip install –upgrade sklearn!pip install scikit-learn==0.23.2 –user!pip install pycaret!pip install markupsafe==2.0.1 Pycaret 을 구글 코랩에서 활성화하기 12from pycaret.utils import enable_colabenable_colab() Colab mode enabled. 데이터 불러오기 12from pycaret.datasets import get_datadataset = get_data('credit') requirejs.config({ paths: { base: '/static/base', plotly: 'https://cdn.plot.ly/plotly-latest.min.js?noext', }, }); .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } LIMIT_BAL SEX EDUCATION MARRIAGE AGE PAY_1 PAY_2 PAY_3 PAY_4 PAY_5 ... BILL_AMT4 BILL_AMT5 BILL_AMT6 PAY_AMT1 PAY_AMT2 PAY_AMT3 PAY_AMT4 PAY_AMT5 PAY_AMT6 default 0 20000 2 2 1 24 2 2 -1 -1 -2 ... 0.0 0.0 0.0 0.0 689.0 0.0 0.0 0.0 0.0 1 1 90000 2 2 2 34 0 0 0 0 0 ... 14331.0 14948.0 15549.0 1518.0 1500.0 1000.0 1000.0 1000.0 5000.0 0 2 50000 2 2 1 37 0 0 0 0 0 ... 28314.0 28959.0 29547.0 2000.0 2019.0 1200.0 1100.0 1069.0 1000.0 0 3 50000 1 2 1 57 -1 0 -1 0 0 ... 20940.0 19146.0 19131.0 2000.0 36681.0 10000.0 9000.0 689.0 679.0 0 4 50000 1 1 2 37 0 0 0 0 0 ... 19394.0 19619.0 20024.0 2500.0 1815.0 657.0 1000.0 1000.0 800.0 0 5 rows × 24 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-b1e931e3-7220-444c-b503-4142de4c821c button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-b1e931e3-7220-444c-b503-4142de4c821c'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1dataset.info() requirejs.config({ paths: { base: '/static/base', plotly: 'https://cdn.plot.ly/plotly-latest.min.js?noext', }, }); &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 24000 entries, 0 to 23999 Data columns (total 24 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 LIMIT_BAL 24000 non-null int64 1 SEX 24000 non-null int64 2 EDUCATION 24000 non-null int64 3 MARRIAGE 24000 non-null int64 4 AGE 24000 non-null int64 5 PAY_1 24000 non-null int64 6 PAY_2 24000 non-null int64 7 PAY_3 24000 non-null int64 8 PAY_4 24000 non-null int64 9 PAY_5 24000 non-null int64 10 PAY_6 24000 non-null int64 11 BILL_AMT1 24000 non-null float64 12 BILL_AMT2 24000 non-null float64 13 BILL_AMT3 24000 non-null float64 14 BILL_AMT4 24000 non-null float64 15 BILL_AMT5 24000 non-null float64 16 BILL_AMT6 24000 non-null float64 17 PAY_AMT1 24000 non-null float64 18 PAY_AMT2 24000 non-null float64 19 PAY_AMT3 24000 non-null float64 20 PAY_AMT4 24000 non-null float64 21 PAY_AMT5 24000 non-null float64 22 PAY_AMT6 24000 non-null float64 23 default 24000 non-null int64 dtypes: float64(12), int64(12) memory usage: 4.4 MB 123456data = dataset.sample(frac=0.95, random_state=786)data_unseen = dataset.drop(data.index)data.reset_index(inplace=True, drop=True)data_unseen.reset_index(inplace=True, drop=True)print('Data for Modeling: ' + str(data.shape))print('Unseen Data For Predictions: ' + str(data_unseen.shape)) requirejs.config({ paths: { base: '/static/base', plotly: 'https://cdn.plot.ly/plotly-latest.min.js?noext', }, }); Data for Modeling: (22800, 24) Unseen Data For Predictions: (1200, 24) setup 123import jinja2from pycaret.classification import *exp_clf101 = setup(data = data, target = 'default', session_id=123) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Description Value 0 session_id 123 1 Target default 2 Target Type Binary 3 Label Encoded None 4 Original Data (22800, 24) 5 Missing Values False 6 Numeric Features 14 7 Categorical Features 9 8 Ordinal Features False 9 High Cardinality Features False 10 High Cardinality Method None 11 Transformed Train Set (15959, 88) 12 Transformed Test Set (6841, 88) 13 Shuffle Train-Test True 14 Stratify Train-Test False 15 Fold Generator StratifiedKFold 16 Fold Number 10 17 CPU Jobs -1 18 Use GPU False 19 Log Experiment False 20 Experiment Name clf-default-name 21 USI 954a 22 Imputation Type simple 23 Iterative Imputation Iteration None 24 Numeric Imputer mean 25 Iterative Imputation Numeric Model None 26 Categorical Imputer constant 27 Iterative Imputation Categorical Model None 28 Unknown Categoricals Handling least_frequent 29 Normalize False 30 Normalize Method None 31 Transformation False 32 Transformation Method None 33 PCA False 34 PCA Method None 35 PCA Components None 36 Ignore Low Variance False 37 Combine Rare Levels False 38 Rare Level Threshold None 39 Numeric Binning False 40 Remove Outliers False 41 Outliers Threshold None 42 Remove Multicollinearity False 43 Multicollinearity Threshold None 44 Remove Perfect Collinearity True 45 Clustering False 46 Clustering Iteration None 47 Polynomial Features False 48 Polynomial Degree None 49 Trignometry Features False 50 Polynomial Threshold None 51 Group Features False 52 Feature Selection False 53 Feature Selection Method classic 54 Features Selection Threshold None 55 Feature Interaction False 56 Feature Ratio False 57 Interaction Threshold None 58 Fix Imbalance False 59 Fix Imbalance Method SMOTE &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8cd9911f-84a2-401a-a8e7-52af20909a6c button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8cd9911f-84a2-401a-a8e7-52af20909a6c'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 모델링1best_model = compare_models() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Model Accuracy AUC Recall Prec. F1 Kappa MCC TT (Sec) ridge Ridge Classifier 0.8254 0.0000 0.3637 0.6913 0.4764 0.3836 0.4122 0.047 lda Linear Discriminant Analysis 0.8247 0.7634 0.3755 0.6794 0.4835 0.3884 0.4132 0.317 gbc Gradient Boosting Classifier 0.8226 0.7789 0.3551 0.6806 0.4664 0.3725 0.4010 5.107 ada Ada Boost Classifier 0.8221 0.7697 0.3505 0.6811 0.4626 0.3690 0.3983 1.204 lightgbm Light Gradient Boosting Machine 0.8210 0.7750 0.3609 0.6679 0.4683 0.3721 0.3977 0.432 rf Random Forest Classifier 0.8199 0.7598 0.3663 0.6601 0.4707 0.3727 0.3965 2.767 et Extra Trees Classifier 0.8092 0.7377 0.3677 0.6047 0.4571 0.3497 0.3657 2.293 lr Logistic Regression 0.7814 0.6410 0.0003 0.1000 0.0006 0.0003 0.0034 0.875 dummy Dummy Classifier 0.7814 0.5000 0.0000 0.0000 0.0000 0.0000 0.0000 0.032 knn K Neighbors Classifier 0.7547 0.5939 0.1763 0.3719 0.2388 0.1145 0.1259 0.846 dt Decision Tree Classifier 0.7293 0.6147 0.4104 0.3878 0.3986 0.2242 0.2245 0.331 svm SVM - Linear Kernel 0.7277 0.0000 0.1017 0.1671 0.0984 0.0067 0.0075 0.418 qda Quadratic Discriminant Analysis 0.5098 0.5473 0.6141 0.2472 0.3488 0.0600 0.0805 0.179 nb Naive Bayes 0.3760 0.6442 0.8845 0.2441 0.3826 0.0608 0.1207 0.046 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-e11450b7-cda5-4b61-84ec-4713e7cb5f31 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-e11450b7-cda5-4b61-84ec-4713e7cb5f31'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1print(best_model) requirejs.config({ paths: { base: '/static/base', plotly: 'https://cdn.plot.ly/plotly-latest.min.js?noext', }, }); RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True, max_iter=None, normalize=False, random_state=123, solver='auto', tol=0.001) 모델 생성 1knn_model = create_model('knn') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Accuracy AUC Recall Prec. F1 Kappa MCC Fold 0 0.7469 0.6020 0.1920 0.3545 0.2491 0.1128 0.1204 1 0.7550 0.5894 0.2092 0.3883 0.2719 0.1402 0.1500 2 0.7506 0.5883 0.1576 0.3459 0.2165 0.0923 0.1024 3 0.7419 0.5818 0.1519 0.3136 0.2046 0.0723 0.0790 4 0.7563 0.5908 0.1490 0.3611 0.2110 0.0954 0.1085 5 0.7550 0.5997 0.1748 0.3720 0.2378 0.1139 0.1255 6 0.7638 0.5890 0.1891 0.4125 0.2593 0.1413 0.1565 7 0.7613 0.6240 0.1633 0.3904 0.2303 0.1163 0.1318 8 0.7619 0.5988 0.1862 0.4037 0.2549 0.1356 0.1500 9 0.7549 0.5756 0.1897 0.3771 0.2524 0.1246 0.1351 Mean 0.7547 0.5939 0.1763 0.3719 0.2388 0.1145 0.1259 Std 0.0065 0.0126 0.0191 0.0279 0.0214 0.0214 0.0230 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-72519489-8e58-45aa-a268-24cd9a3c83d2 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-72519489-8e58-45aa-a268-24cd9a3c83d2'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 12345678import numpy as npparams = { 'n_neighbors' : np.arange(0,50,1)}tunned_knn = tune_model(knn_model,custom_grid=params)print(tunned_knn) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Accuracy AUC Recall Prec. F1 Kappa MCC Fold 0 0.7813 0.6482 0.0372 0.5000 0.0693 0.0402 0.0876 1 0.7807 0.6436 0.0315 0.4783 0.0591 0.0330 0.0759 2 0.7744 0.6563 0.0315 0.3333 0.0576 0.0206 0.0403 3 0.7845 0.6589 0.0659 0.5610 0.1179 0.0754 0.1345 4 0.7826 0.6645 0.0315 0.5500 0.0596 0.0368 0.0903 5 0.7794 0.6477 0.0544 0.4634 0.0974 0.0539 0.0961 6 0.7826 0.6278 0.0630 0.5238 0.1125 0.0688 0.1214 7 0.7751 0.6702 0.0372 0.3611 0.0675 0.0278 0.0523 8 0.7813 0.6409 0.0630 0.5000 0.1120 0.0662 0.1146 9 0.7881 0.6426 0.0661 0.6389 0.1198 0.0822 0.1548 Mean 0.7810 0.6501 0.0482 0.4910 0.0873 0.0505 0.0968 Std 0.0039 0.0119 0.0148 0.0861 0.0255 0.0206 0.0338 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-33cf8c79-c42e-4ef5-873a-23afc3c6e178 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-33cf8c79-c42e-4ef5-873a-23afc3c6e178'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski', metric_params=None, n_jobs=-1, n_neighbors=42, p=2, weights='uniform') auc 최소 0.5 좋은 모델 기준 0.8이상 최고 1 1plot_model(tunned_knn,plot='auc') 123# 의사 결정 트리# plot_model(tunned_knn,plot='feature')plot_model(tunned_knn,plot='confusion_matrix') 1evaluate_model(tunned_knn) requirejs.config({ paths: { base: '/static/base', plotly: 'https://cdn.plot.ly/plotly-latest.min.js?noext', }, }); interactive(children=(ToggleButtons(description='Plot Type:', icons=('',), options=(('Hyperparameters', 'param… 1models() requirejs.config({ paths: { base: '/static/base', plotly: 'https://cdn.plot.ly/plotly-latest.min.js?noext', }, }); .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Reference Turbo ID lr Logistic Regression sklearn.linear_model._logistic.LogisticRegression True knn K Neighbors Classifier sklearn.neighbors._classification.KNeighborsCl... True nb Naive Bayes sklearn.naive_bayes.GaussianNB True dt Decision Tree Classifier sklearn.tree._classes.DecisionTreeClassifier True svm SVM - Linear Kernel sklearn.linear_model._stochastic_gradient.SGDC... True rbfsvm SVM - Radial Kernel sklearn.svm._classes.SVC False gpc Gaussian Process Classifier sklearn.gaussian_process._gpc.GaussianProcessC... False mlp MLP Classifier sklearn.neural_network._multilayer_perceptron.... False ridge Ridge Classifier sklearn.linear_model._ridge.RidgeClassifier True rf Random Forest Classifier sklearn.ensemble._forest.RandomForestClassifier True qda Quadratic Discriminant Analysis sklearn.discriminant_analysis.QuadraticDiscrim... True ada Ada Boost Classifier sklearn.ensemble._weight_boosting.AdaBoostClas... True gbc Gradient Boosting Classifier sklearn.ensemble._gb.GradientBoostingClassifier True lda Linear Discriminant Analysis sklearn.discriminant_analysis.LinearDiscrimina... True et Extra Trees Classifier sklearn.ensemble._forest.ExtraTreesClassifier True lightgbm Light Gradient Boosting Machine lightgbm.sklearn.LGBMClassifier True dummy Dummy Classifier sklearn.dummy.DummyClassifier True &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-0fc05d64-8925-4e82-bde7-8a672bf8ddd2 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-0fc05d64-8925-4e82-bde7-8a672bf8ddd2'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt;","link":"/2022/07/05/0705_PycaretSample/"},{"title":"day0705_ch5_ch6","text":"트리의 앙상블 랜덤 포레스트 ( 나무1개 ) 여러 개 심음 샘플링 Feature Importance 예측해야할 행의 갯수, 100만개 컬럼의 갯수 200개 —&gt; 100개 나무 100개르 심고 평균을 내자 나무 1개 당 컬럼을 10개로 T1 mae : 20 / T2 mae : 30 / T3 : mae : 10 …. T1 ~ T100 mae : 200 Feature Importance sampling : bootstrap (복원추출) 123456789101112131415161718192021222324252627282930# 라이브러리 불러오기import numpy as npimport pandas as pdfrom sklearn.model_selection import train_test_split# 데이터 불러오기wine = pd.read_csv('http://bit.ly/wine_csv_data')# input, target 분리data = wine [['alcohol','sugar','pH']].to_numpy()target = wine['class'].to_numpy()# 훈련 데이터, 테스트 데이터 분리train_input, test_input, train_target, test_target = train_test_split( data, target, test_size=0.2, random_state=42)# 모델링from sklearn.model_selection import cross_validatefrom sklearn.ensemble import RandomForestClassifierrf = RandomForestClassifier(n_jobs=-1, random_state=42)# 모형 평가scores = cross_validate(rf,train_input,train_target, return_train_score=True, n_jobs=-1)print(np.mean(scores['train_score']),np.mean(scores['test_score']))# 특성 중요rf.fit(train_input, train_target)print(rf.feature_importances_) 0.9973541965122431 0.8905151032797809 [0.23167441 0.50039841 0.26792718] 12345# 00Brf = RandomForestClassifier(oob_score = True, n_jobs=-1,random_state=42)rf.fit(train_input, train_target)print(rf.oob_score_) 0.8934000384837406 엑스트라 트리 123456from sklearn.ensemble import ExtraTreesClassifieret = ExtraTreesClassifier(n_jobs=-1, random_state=42)scores = cross_validate(et, train_input, train_target, return_train_score=True, n_jobs=-1)print(np.mean(scores['train_score']), np.mean(scores['test_score'])) 0.9974503966084433 0.8887848893166506 12et.fit(train_input, train_target)print(et.feature_importances_) [0.20183568 0.52242907 0.27573525] 그레이디언트 부스팅 # 개념만 이해하면 된다. 경사하강법의 원리를 이용함 T1 ~ TN 증가하면서 오차를 보정해주며 정확성을 높임 랜덤포레스트와의 차이점 랜덤포레스트는 각 나무 간 상호 연관성 없음 부스팅은 각 나무 간 상호 연관성 있음 단점 속도가 너무 느리다 대안 XBoost, LightGBM 123456from sklearn.ensemble import GradientBoostingClassifiergb = GradientBoostingClassifier(random_state=42)scores = cross_validate(gb, train_input, train_target, return_train_score=True, n_jobs=-1)print(np.mean(scores['train_score']), np.mean(scores['test_score'])) 0.8881086892152563 0.8720430147331015 1234gb = GradientBoostingClassifier(n_estimators=500, learning_rate=0.2, random_state=42)scores = cross_validate(gb, train_input, train_target, return_train_score=True, n_jobs=-1)print(np.mean(scores['train_score']), np.mean(scores['test_score'])) 0.9464595437171814 0.8780082549788999 12gb.fit(train_input, train_target)print(gb.feature_importances_) [0.15872278 0.68010884 0.16116839] 히스토그램 기반 그레이디언트 부스팅 하지말기. 06-1 군집 알고리즘실무에서의 난이도비지도학습 &gt;&gt;&gt; 지도 학습비지도 학습–&gt; 분류–&gt; 수치적으로 분류 주성분 분석 이론적으로는 어려움 좌표계 공간 개념 직교 + 회전 공분산 등 ( 통계 관련 내용 ) Feature Engineering 기법 StandardScaler() 현 ML(Machine LEarning)의 문제점:컬럼의 갯수가 너무 !! 많다. 왜 많냐면 .. 차원 축소 특성이 많으면 훈련 데이터에 쉽게 과대적합된다. 특성을 줄여서 학습 모델의 성능을 향산시킨다. 모델의 학습 시간을 감소시켜줌 대표적인 방법론 중 둘 : PCA, EFA EFA / PCA EFA( 탐색적 요인 분석 ) (= Factor Analysis ) 국어, 수학, 과학, 영어 국어 40, 수학 100 과학 100 영어 30/ 귀 학생을 언어영억은 수준이 낮은편이나 수리영역은 매우 수준이 높습니다. 범주형 &amp; 수치 데이터 셋 PCA ( 주성분 분석 ) 장비1, 장비2, 장비3, , , , pc1, pc2, pc3, pc4,,, 원래 가지고 있던 정보를 알 수 없음.(정보손실) 범주형 데이터셋에는 사용 안됨 무조건 수치형 데이터에서만 사용 pca 하기 전, 표준화하기(스케일링 실행)= x축, y축의 단위 동일화하기. 123# 데이터 가져오기 !wget https://bit.ly/fruits_300_data -O fruits_300.npy # zero아니고 alphabet O다.# p.287에 ! 는 뭔가요 보기. --2022-07-05 04:47:49-- https://bit.ly/fruits_300_data Resolving bit.ly (bit.ly)... 67.199.248.11, 67.199.248.10 Connecting to bit.ly (bit.ly)|67.199.248.11|:443... connected. HTTP request sent, awaiting response... 301 Moved Permanently Location: https://github.com/rickiepark/hg-mldl/raw/master/fruits_300.npy [following] --2022-07-05 04:47:49-- https://github.com/rickiepark/hg-mldl/raw/master/fruits_300.npy Resolving github.com (github.com)... 192.30.255.112 Connecting to github.com (github.com)|192.30.255.112|:443... connected. HTTP request sent, awaiting response... 302 Found Location: https://raw.githubusercontent.com/rickiepark/hg-mldl/master/fruits_300.npy [following] --2022-07-05 04:47:50-- https://raw.githubusercontent.com/rickiepark/hg-mldl/master/fruits_300.npy Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.109.133, 185.199.110.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 3000128 (2.9M) [application/octet-stream] Saving to: ‘fruits_300.npy’ fruits_300.npy 100%[===================&gt;] 2.86M --.-KB/s in 0.05s 2022-07-05 04:47:50 (60.3 MB/s) - ‘fruits_300.npy’ saved [3000128/3000128] 12345678# 라이브러리 불러오기import numpy as npfruits = np.load('fruits_300.npy')fruits_2d = fruits.reshape(-1,100*100)# 확인이나 해보자print(fruits)print(fruits_2d) [[[1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] ... [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1]] [[1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] ... [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1]] [[1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] ... [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1]] ... [[1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] ... [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1]] [[1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] ... [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1]] [[1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] ... [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1]]] [[1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] ... [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1] [1 1 1 ... 1 1 1]] 12345# 모델링from sklearn.decomposition import PCApca = PCA(n_components = 50 )pca.fit(fruits_2d)# 10,000개의 데이터를 50개로 줄인다는 뜻이다. PCA(n_components=50) 1print(pca.components_.shape) (50, 10000) 12345678910111213141516import matplotlib.pyplot as pltdef draw_fruits(arr, ratio=1): n = len(arr) # n은 샘플 개수입니다 # 한 줄에 10개씩 이미지를 그립니다. 샘플 개수를 10으로 나누어 전체 행 개수를 계산합니다. rows = int(np.ceil(n/10)) # 행이 1개 이면 열 개수는 샘플 개수입니다. 그렇지 않으면 10개입니다. cols = n if rows &lt; 2 else 10 fig, axs = plt.subplots(rows, cols, figsize=(cols*ratio, rows*ratio), squeeze=False) for i in range(rows): for j in range(cols): if i*10 + j &lt; n: # n 개까지만 그립니다. axs[i, j].imshow(arr[i*10 + j], cmap='gray_r') axs[i, j].axis('off') plt.show() 12print(pca.components_.reshape(-1,100,100))# 나는 왜 그림이 나오지 않는 것인가 !! [[[ 9.24490195e-06 5.10601298e-06 8.91640398e-06 ... 3.64260921e-06 9.34252918e-07 4.67126459e-06] [ 1.15833514e-05 5.76383497e-07 4.14828737e-06 ... 0.00000000e+00 9.02785432e-07 0.00000000e+00] [ 5.83134163e-06 2.29451889e-06 1.61700364e-06 ... 0.00000000e+00 4.60832962e-06 0.00000000e+00] ... [ 0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 0.00000000e+00 0.00000000e+00 0.00000000e+00] [ 0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 0.00000000e+00 0.00000000e+00 0.00000000e+00] [ 0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 0.00000000e+00 0.00000000e+00 0.00000000e+00]] [[-1.69701613e-05 -1.13551047e-05 -1.82152561e-05 ... -6.85415826e-06 -1.72461747e-06 -8.62308735e-06] [-1.83988224e-05 -5.12361973e-06 -6.86007645e-06 ... -0.00000000e+00 -1.70984693e-06 -0.00000000e+00] [-9.48385290e-06 -3.28956277e-06 -1.59769056e-06 ... -0.00000000e+00 -8.59354627e-06 -0.00000000e+00] ... [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00] [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00] [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00]] [[-3.65220479e-05 -2.08401744e-05 -2.89870138e-05 ... -1.07455043e-05 -2.28430243e-06 -1.14215121e-05] [-4.71494348e-05 -3.76266648e-06 -1.07501288e-05 ... -0.00000000e+00 -2.82040061e-06 -0.00000000e+00] [-2.23009741e-05 -8.26967039e-06 -6.95529298e-06 ... -0.00000000e+00 -1.24937085e-05 -0.00000000e+00] ... [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00] [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00] [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00]] ... [[-2.51432593e-05 -7.92600954e-05 -8.23607786e-05 ... -1.83469572e-06 -4.11988751e-06 -2.05994376e-05] [-7.92507818e-05 -2.81531763e-05 -3.39914008e-05 ... -0.00000000e+00 7.61730597e-07 -0.00000000e+00] [-5.33663918e-05 -4.56116856e-05 -3.15206037e-05 ... -0.00000000e+00 -1.08362013e-05 -0.00000000e+00] ... [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00] [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00] [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00]] [[ 2.57743887e-05 7.93202087e-05 1.00202288e-04 ... -2.14844721e-05 -2.89642108e-06 -1.44821054e-05] [ 2.31050308e-06 6.06796251e-05 3.07111026e-05 ... -0.00000000e+00 -6.19601701e-06 -0.00000000e+00] [ 6.96702046e-05 2.55759163e-05 -5.23724211e-06 ... -0.00000000e+00 -2.10812973e-05 -0.00000000e+00] ... [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00] [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00] [-0.00000000e+00 -0.00000000e+00 -0.00000000e+00 ... -0.00000000e+00 -0.00000000e+00 -0.00000000e+00]] [[ 1.37760143e-04 -5.05654438e-05 -1.52581078e-05 ... 9.64447604e-05 1.79898700e-05 8.99493501e-05] [ 1.00495763e-04 -7.18134056e-06 -1.82977600e-05 ... 0.00000000e+00 2.61516301e-05 0.00000000e+00] [-6.08594244e-05 -6.22125611e-05 1.39415799e-05 ... 0.00000000e+00 1.06272870e-04 0.00000000e+00] ... [ 0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 0.00000000e+00 0.00000000e+00 0.00000000e+00] [ 0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 0.00000000e+00 0.00000000e+00 0.00000000e+00] [ 0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 0.00000000e+00 0.00000000e+00 0.00000000e+00]]] 1print(fruits_2d.shape) (300, 10000) 123# ML 에서 컬럼의 갯수를 10,000개를 50개로 줄인 것인다.. ( =압축 )fruits_pca = pca.transform(fruits_2d)print(fruits_pca.shape) (300, 50) 원본 데이터 재구성 12fruits_inverse = pca.inverse_transform(fruits_pca)print(fruits_inverse.shape) (300, 10000) 1234fruits_reconstruct = fruits_inverse.reshape(-1,100,100)for start in [0,100,200]: draw_fruits(fruits_reconstruct[start:start+100]) print(&quot;\\n&quot;) 설명된 분산 = 주성분이 원본 데이터의 분산을 얼마나 잘 나타내는지 기록한 값 1234# 92%# 원본 이미지 압축print(np.sum(pca.explained_variance_ratio_)) 0.9215747829079223 12plt.plot(pca.explained_variance_ratio_)plt.show() PCA의 기능을 알아두자.정확도는 조금 떨어지지만(92%) 속도가 빨라진다 (20배)12","link":"/2022/07/05/Day0705_ch05_ch6/"},{"title":"day0705_CookBook","text":"Cook BookIdioms12345678# 오 ㅋㅋ스스로 import pandas as pd 했어 ㅋㅋㅋ 대견해 나이스 import pandas as pddf = pd.DataFrame( {&quot;AAA&quot;:[4,5,6,7],&quot;BBB&quot;:[10,20,30,40],&quot;CCC&quot;:[100,50,-30,-50]})df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-9346839e-14eb-4e53-a36f-b9145eb697f5 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-9346839e-14eb-4e53-a36f-b9145eb697f5'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; if - then 1234# loc 랑 iloc 비교했었는데 기억 안 난다. 찾아봐야지.# 이거 돌려보니 그냥 if else elif 그런 느끼이네.df.loc[df.AAA &gt;=5, &quot;BBB&quot;]=-1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } AAA BBB CCC 0 4 10 100 1 5 -1 50 2 6 -1 -30 3 7 -1 -50 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-dffa7f31-e287-454d-bc96-06b91fcf8e19 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-dffa7f31-e287-454d-bc96-06b91fcf8e19'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; if-then with assignment to 2 columns: 12df. loc[df.AAA &gt;= 5, [&quot;BBB&quot;,&quot;CCC&quot;]] = 555df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } AAA BBB CCC 0 4 10 100 1 5 555 555 2 6 555 555 3 7 555 555 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-4d6c016a-a647-4a4f-beda-fd4c3c4714b9 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-4d6c016a-a647-4a4f-beda-fd4c3c4714b9'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Add another line with different logic, to do the - else 12df.loc[df.AAA &lt; 5, [&quot;BBB&quot;,&quot;CCC&quot;]]=2000df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } AAA BBB CCC 0 4 2000 2000 1 5 555 555 2 6 555 555 3 7 555 555 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-c5caac8b-1218-49d9-8d9e-61622dd2e414 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-c5caac8b-1218-49d9-8d9e-61622dd2e414'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Or use pandas where after you’ve set up a mask 123456789df_mask = pd.DataFrame( {&quot;AAA&quot;:[True]*4, &quot;BBB&quot;:[False]*4, &quot;CCC&quot;:[True,False]*2})df.where(df_mask,-1000)# mask 가 뭘까?# .where은 뭐지? 봤던듯 안봤던듯 본 것 같은 너## False 인 곳에 -1000을 넣겠다는 것 같다. 찾아보고 결론짓기. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } AAA BBB CCC 0 4 -1000 2000 1 5 -1000 -1000 2 6 -1000 555 3 7 -1000 -1000 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-595f8f18-759e-4ccf-b1fd-29933f0da364 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-595f8f18-759e-4ccf-b1fd-29933f0da364'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; if-then-else using Numpy’s where() 12345df = pd.DataFrame( {&quot;AAA&quot;:[4,5,6,7],&quot;BBB&quot;:[10,20,30,40],&quot;CCC&quot;:[100,50,-30,-50]})df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } AAA BBB CCC 0 4 10 100 1 5 20 50 2 6 30 -30 3 7 40 -50 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-7a76ad5b-8b74-4d0f-ab68-b0b3c528e134 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-7a76ad5b-8b74-4d0f-ab68-b0b3c528e134'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123import numpy as npdf[&quot;logic&quot;] = np.where(df[&quot;AAA&quot;]&gt;5,&quot;high&quot;,&quot;low&quot;)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } AAA BBB CCC logic 0 4 10 100 low 1 5 20 50 low 2 6 30 -30 high 3 7 40 -50 high &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-f375dcda-01a5-4f91-8390-85d9ef6d1476 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-f375dcda-01a5-4f91-8390-85d9ef6d1476'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt;","link":"/2022/07/05/DAy0705_Pansdas_CookBook/"},{"title":"day0706_ch7_etc","text":"데이터 분석 ( 머신러닝, 딥러닝 ) 프로세스 데이트 불러오기 CSV, 오라클, MySQL, PstgreSQL, Cloud DB, 연동 연동 탐색적 자료 분석 데이터 전처리 및 가공 잠정적인 컬럼의 갯수를 지정함 머신러닝 모델 ( = 통계 모델링, t.tset, 분산분석, 교차분석 ) 머신러닝 모델의 경우 배포는 나중에 배우자. JSP 웹개발 시, 배우게 될 것이다. 통계 모델링의 경우, p-value 값 기준으로 귀무가설 및 대립가설 검정 ( 공통 ) 결과 보고서를 작성해야 함. PPT 만들어야 한다. 사기업:매출로 능력을 증명 / 공기업:결과검증? 그래프 복습 수치형 데이터 시각화 범주형 데이터 시각화 데이터 관계 시각화 matplotlib 라이브러리 방법 ( 복잡 ) saborn 라이브러리 방법 ( 단순 ) 복잡한 그래프 그리기 –&gt; matplotlib 써야함. 한 줄 그래프 –&gt; seaborn 으로. 수치형 데이터 시각화 1234import seaborn as snstitanic = sns.load_dataset('titanic')print(titanic.head())# survived, pclass, sibsp 가 의미하는게 뭔지 알아야한다!!! survived pclass sex age sibsp parch fare embarked class \\ 0 0 3 male 22.0 1 0 7.2500 S Third 1 1 1 female 38.0 1 0 71.2833 C First 2 1 3 female 26.0 0 0 7.9250 S Third 3 1 1 female 35.0 1 0 53.1000 S First 4 0 3 male 35.0 0 0 8.0500 S Third who adult_male deck embark_town alive alone 0 man True NaN Southampton no False 1 woman False C Cherbourg yes False 2 woman False NaN Southampton yes True 3 woman False C Southampton yes False 4 man True NaN Southampton no True 12# 히스토그램sns.histplot(data= titanic,x='age', bins=15 ,hue='alive',multiple='stack') &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fafe24c2410&gt; 위 그래프를 보면 balh blah blah blah blah 해야한다. 123# 커널 밀도 추정 함수 그래프# 연속형 데이터 1 개만 쓸 때 사용sns.kdeplot(data=titanic, x='age',hue='alive',multiple='stack') &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fafdba44cd0&gt; 분포도 수치형 데이터 한 개 컬럼의 분포를 나타내는 그래프. 정규분포인지 아닌가 구분.. 1sns.displot(data=titanic, x= 'age',kde = True ) &lt;seaborn.axisgrid.FacetGrid at 0x7fafd6f15c90&gt; 범주형 데이터 x축 범주형, y축 수치 데이터 x축 범주형, y축 범주형(특이한 케이스) 히트맵 1234# 막대 그래프sns.barplot( x='class',y='fare',data=titanic )# error bar = 오차막대# 등급이 올라갈 수록 요금이 비싸진다... &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fafd6b88e10&gt; 12# 포인트 플롯sns.pointplot( x = 'class', y = 'fare',data = titanic ) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fafd6a6aa90&gt; 박스 플롯 제 1사분위 : 전체 데이터 중에 하위 25% 사분위 범위 수 (IQR) : 제3사분위- 제1사분위 최댓값 : 제3사분위 + (1.5 * IQ) 123# 박스 플롯sns.boxplot ( x = 'class', y = 'age', data = titanic) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fafd6b97650&gt; 12# 바이올린 플롯sns.violinplot(x='class',y='age',hue='sex',data=titanic,split=True); 카운트 플롯 범주형 데이터의 갯수를 확인 할 때 사용 1sns.countplot(x='alive',data=titanic) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fafd67645d0&gt; 데이터 관계 시각화 여러 데이터 사이의 관계도를 파악하기 위한 그래 히트맵 12flights = sns.load_dataset('flights')flights.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } year month passengers 0 1949 Jan 112 1 1949 Feb 118 2 1949 Mar 132 3 1949 Apr 129 4 1949 May 121 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-d25e0854-b653-4b1c-8612-7b904198501f button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-d25e0854-b653-4b1c-8612-7b904198501f'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 각 연도, 월별 승객수 구하기 123456789# flights['year'].value_counts()#flights_pivot = import pandas as pddf= pd.DataFrame({'foo': ['one', 'one', 'one', 'two', 'two', 'two'], 'bar': ['A', 'B', 'C', 'A', 'B', 'C'], 'baz': [1, 2, 3, 4, 5, 6], 'zoo': ['x', 'y', 'z', 'q', 'w', 't']})df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } foo bar baz zoo 0 one A 1 x 1 one B 2 y 2 one C 3 z 3 two A 4 q 4 two B 5 w 5 two C 6 t &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-2e9bd0ac-5ae7-4baa-9207-6280fc3d0b72 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-2e9bd0ac-5ae7-4baa-9207-6280fc3d0b72'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 12# 사이트 복붙//한번 돌려보고 어디서 어디에 쓰이는지 보고 ''에 넣기.df.pivot(index='foo', columns='bar', values='baz') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } bar A B C foo one 1 2 3 two 4 5 6 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-ef7f377c-07ae-40cc-87c5-33a081e091fc button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-ef7f377c-07ae-40cc-87c5-33a081e091fc'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1flights .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } year month passengers 0 1949 Jan 112 1 1949 Feb 118 2 1949 Mar 132 3 1949 Apr 129 4 1949 May 121 ... ... ... ... 139 1960 Aug 606 140 1960 Sep 508 141 1960 Oct 461 142 1960 Nov 390 143 1960 Dec 432 144 rows × 3 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-77f61489-7529-4460-a4af-ea2c3d2c8c0f button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-77f61489-7529-4460-a4af-ea2c3d2c8c0f'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123# flights['year'].value_counts()flights_pivot = flights.pivot(index = 'month', columns = 'year', values = 'passengers')flights_pivot .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } year 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 month Jan 112 115 145 171 196 204 242 284 315 340 360 417 Feb 118 126 150 180 196 188 233 277 301 318 342 391 Mar 132 141 178 193 236 235 267 317 356 362 406 419 Apr 129 135 163 181 235 227 269 313 348 348 396 461 May 121 125 172 183 229 234 270 318 355 363 420 472 Jun 135 149 178 218 243 264 315 374 422 435 472 535 Jul 148 170 199 230 264 302 364 413 465 491 548 622 Aug 148 170 199 242 272 293 347 405 467 505 559 606 Sep 136 158 184 209 237 259 312 355 404 404 463 508 Oct 119 133 162 191 211 229 274 306 347 359 407 461 Nov 104 114 146 172 180 203 237 271 305 310 362 390 Dec 118 140 166 194 201 229 278 306 336 337 405 432 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-730ee421-750b-405e-911c-5ddf693c139d button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-730ee421-750b-405e-911c-5ddf693c139d'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1sns.heatmap(data=flights_pivot) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fafd6346350&gt; 12# 라인 플롯sns.lineplot(x='year',y='passengers',data=flights) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fafd67495d0&gt; 123# 산점도tips= sns.load_dataset('tips')tips.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } total_bill tip sex smoker day time size 0 16.99 1.01 Female No Sun Dinner 2 1 10.34 1.66 Male No Sun Dinner 3 2 21.01 3.50 Male No Sun Dinner 3 3 23.68 3.31 Male No Sun Dinner 2 4 24.59 3.61 Female No Sun Dinner 4 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-3c50c4e0-1f4a-4b81-8c78-eec4fc98ba09 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-3c50c4e0-1f4a-4b81-8c78-eec4fc98ba09'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 두 개의 연속형 데이터 12sns.scatterplot(x='total_bill', y='tip', data=tips, hue='sex') &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fafd64e3250&gt; 12# 회귀선sns.regplot(x='total_bill',y='tip',data=tips) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fafd648c210&gt; 머신러닝 리뷰 가장 인기 있는 모델 LightGBM, dXGBoost 선형 회귀 선형 회귀식을 찾는 것이 중요하다. $y = 3x+ 4$ 에 근사한 데이터 50 개 생 123456789101112131415import numpy as npimport pandas as pd# 시드값 고정np.random.seed(0)intercept = 4 slope=3 # 변동성을 주기 위해서 노이즈를 생성한다.noise = np.random.randn(50,1)x = 5* np.random.rand(50,1)# 0과 5 사이의 실수값 50개를 생성y = slope * x + intercept + noise# 데이터 프레임 생성data = pd.DataFrame({'X':x[:,0],'Y':y[:,0]})print(data) X Y 0 0.794848 8.148596 1 0.551876 6.055784 2 3.281648 14.823682 3 0.690915 8.313637 4 0.982912 8.816293 5 1.843626 8.553600 6 4.104966 17.264987 7 0.485506 5.305162 8 4.189725 16.465955 9 0.480492 5.852075 10 4.882297 18.790936 11 2.343256 12.484042 12 4.883805 19.412454 13 3.024228 13.194358 14 3.696318 15.532817 15 0.195939 4.921491 16 1.414035 9.736184 17 0.600983 5.597790 18 1.480701 8.755171 19 0.593639 4.926820 20 1.589916 6.216758 21 2.071315 10.867564 22 0.320737 5.826649 23 3.462361 13.644917 24 2.833007 14.768776 25 1.326947 6.526477 26 2.616240 11.894479 27 0.469703 5.221924 28 2.879732 14.171977 29 4.646481 19.408802 30 1.592845 8.933482 31 3.337052 14.389318 32 0.658989 5.089182 33 3.581636 12.764112 34 1.447030 7.993179 35 0.915957 6.904219 36 2.932565 14.027985 37 0.100538 5.503993 38 4.144700 16.046774 39 0.023477 3.768129 40 3.389083 13.118695 41 1.350040 6.630102 42 3.675970 13.321640 43 4.810943 20.383604 44 1.243766 7.221645 45 2.880787 12.204286 46 2.960210 11.627834 47 2.861260 13.361269 48 1.115408 5.732327 49 4.763745 18.078495 1234import matplotlib.pyplot as pltfig,ax = plt.subplots()ax.scatter(data['X'],data['Y'])plt.show() 12import seaborn as snssns.scatterplot(x='X',y='Y',data=data) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fafd4075e50&gt; 선형회귀 모형 훈련 모형 생성 후, 회귀계수 3과, y절편 4에 근사한 값이 나와야 함 123456from sklearn.linear_model import LinearRegression lr_model = LinearRegression() # 선형 회귀 모델 lr_model.fit(x, y) # 모델 훈련print('y절편:', lr_model.intercept_)print('회귀계수:', lr_model.coef_) y절편: [4.05757639] 회귀계수: [[3.03754061]] 1234567891011# 예측값y_pred = lr_model.predict(x)fig, ax = plt.subplots()ax.scatter(x, y)ax.plot(x, y_pred, color='green')# slope, intercept label = 'slope: {}\\nintercept: {}'.format(round(lr_model.coef_[0][0], 2), round(lr_model.intercept_[0], 2))ax.text(3.5, 4, label, style ='italic', fontsize = 10, color =&quot;green&quot;)plt.show() 1234567891011121314151617181920import numpy as npimport matplotlib.pyplot as pltdef sigmoid(arr, scale=1): arr = np.asarray(arr) result = 1/(1 + np.exp(-arr*scale)) return resultx = np.linspace(-6, 6)y = sigmoid(x)fig, ax = plt.subplots()ax.plot(x, y)ax.grid(which='major', axis='y', linestyle='--')ax.axvline(x=0, color='r', linestyle='--', linewidth=1)ax.set_ylim(0,1)ax.set_yticks([0, 1, 0.5])ax.text(0-0.1, 0.5, '0.5', ha='right')ax.set_title('Sigmoid Graph')plt.show() 12345678910111213# 라이브러리 불러오기import matplotlib.pyplot as pltimport numpy as npfrom sklearn.linear_model import LogisticRegressionfrom sklearn.metrics import classification_report, confusion_matrix# 데이터 가져오기x = np.arange(10).reshape(-1, 1)y = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1])# 모델 생성 및 학습model = LogisticRegression(solver='liblinear', C=10.0, random_state=0)model.fit(x, y) LogisticRegression(C=10.0, random_state=0, solver='liblinear') 123# 모형 평가p_pred = model.predict_proba(x)print('p_pred',p_pred,sep='\\n') p_pred [[0.97979027 0.02020973] [0.94958202 0.05041798] [0.87976149 0.12023851] [0.73975066 0.26024934] [0.52477284 0.47522716] [0.30020373 0.69979627] [0.1428487 0.8571513 ] [0.06080627 0.93919373] [0.02453462 0.97546538] [0.00967652 0.99032348]] 12y_pred=model.predict(x)print('y_pred',y_pred) y_pred [0 0 0 0 0 1 1 1 1 1] 12345678910fig, ax = plt.subplots()ax.scatter(x, y)ax.plot(x, p_pred[:, 1], color = 'black', marker='o', markersize=6)ax.plot()ax.set_xticks(x)ax.set_yticks(np.arange(0, 1.1, 0.1))ax.grid(which='major', alpha=0.5)plt.show() 12conf_m = confusion_matrix(y, y_pred)print(conf_m) [[5 0] [0 5]] 1234567891011121314cm = confusion_matrix(y, y_pred)fig, ax = plt.subplots(figsize=(8, 8))ax.imshow(cm, cmap = 'Pastel2')ax.grid(False)ax.xaxis.set(ticks=(0, 1), ticklabels=('Predicted 0', 'Predicted 1'))ax.yaxis.set(ticks=(0, 1), ticklabels=('Actual 0', 'Actual 1'))ax.set_ylim(1.5, -0.5)for i in range(2): for j in range(2): ax.text(j, i, cm[i, j], ha='center', va='center', color='black', fontsize=20)plt.show()# for i~ fontsize DIY 가능 결정트리 분류와 회귀 문제에 모두 사용 가능 주요 개념 작동 원리 데이터를 가장 잘 구분하는 조건을 정함. 조건을 기준으로 데이터를 두 범주로 나눔 나뉜 각 범주의 데이터를 구분하는 조건을 정함 각 조건을 기준으로 데이터를 두 범주로 나눔 언제까지 계속 분할할지 정한 후, 최종 결정 값을 구함. 불순도(Impurity) 한 범주 안에 서로 다른 데이터가 얼마나 섞여 있는지 나타냄 흰색과 검은색이 50:50으로 섞여 있다. (불순도 최대) 흰색과 검은색으로 완전 분리 되었다. (불순도 최소) 엔트로피(Entropy) 불확실한 정도를 의미함. 0 ~ 1로 정함. 흰색과 검은색이 50:50으로 섞여 있다. 엔트로피 1 흰색과 검은색으로 완전 분리 되었다. 엔트로피 0 정보이득(Information Gain) 1에서 엔트로피를 뺀 수치 정보 이득을 최대화하는 방향(엔트로피를 최소화 하는 방향)으로 노드를 분할함 지니 불순도(Gini Impurity) 지니 불순도 값이 클수록 불순도도 높고, 작을수록 불순도도 낮음. 엔트로피와 마찬가지로 지니 불순도가 낮아지는 방향으로 노드 분할함. 1234567from sklearn.tree import DecisionTreeClassifierfrom sklearn.model_selection import train_test_split import seaborn as sns # tips 데이터셋 titanic = sns.load_dataset('titanic')titanic.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 891 entries, 0 to 890 Data columns (total 15 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 survived 891 non-null int64 1 pclass 891 non-null int64 2 sex 891 non-null object 3 age 714 non-null float64 4 sibsp 891 non-null int64 5 parch 891 non-null int64 6 fare 891 non-null float64 7 embarked 889 non-null object 8 class 891 non-null category 9 who 891 non-null object 10 adult_male 891 non-null bool 11 deck 203 non-null category 12 embark_town 889 non-null object 13 alive 891 non-null object 14 alone 891 non-null bool dtypes: bool(2), category(2), float64(2), int64(4), object(5) memory usage: 80.7+ KB survived의 비율을 구해보자 0: 사망자 1: 생존자 1titanic['survived'] . value_counts() 0 549 1 342 Name: survived, dtype: int64 1234567# 데이터 추출X = titanic[['pclass', 'parch', 'fare']]y = titanic['survived']# 훈련데이터, 테스트 데이터 분리X_train, X_test, y_train, y_test = train_test_split(X, y, stratify = y, test_size = 0.3, random_state=42)X_train.shape, X_test.shape, y_train.shape, y_test.shape ((623, 3), (268, 3), (623,), (268,)) 12345tree_model = DecisionTreeClassifier()tree_model.fit(X_train, y_train)acc = tree_model.score(X_test, y_test)print(f'모형 정확도 : {acc:.3f}') # 정확도 측정 모형 정확도 : 0.675 랜덤 포레스12345678910111213141516171819from sklearn.ensemble import RandomForestClassifierfrom sklearn.model_selection import train_test_split import seaborn as sns # tips 데이터셋 titanic = sns.load_dataset('titanic')X = titanic[['pclass', 'parch', 'fare']]y = titanic['survived']# 훈련데이터, 테스트 데이터 분리X_train, X_test, y_train, y_test = train_test_split(X, y, stratify = y, test_size = 0.3, random_state=42)# 모델 훈련rf_model = RandomForestClassifier(random_state=42) # 랜덤 포레스트 정의rf_model.fit(X_train, y_train)acc = rf_model.score(X_test, y_test)print(f'모형 정확도 : {acc:.3f}') # 정확도 측정 모형 정확도 : 0.675 XGBoost &amp; LightGBM ( 2016 , 2017년 ) 전통적인 머신러닝 알고리즘의 융합 선형회귀 릿지 라쏘, 과적합 방지를 위한 규제 결정 트리의 핵심적인 알고리즘 경사 하강법 문제점 : 파라미터의 개수가 매우 많음. 왜 많이 쓸까?? 모델 학습 속도 높아야 성능 좋아야 가장 좋은 모델이란, 학습 속도는 빠르고 성능은 최고 기준 : 지금까지 나온 알고리즘 Python JAVA, C, C++ C, C++ / r data.table 패키지 큰회사들 개발 첫 번째 옵션, 우리가 자체적으로 배포하자. –&gt; Python Wrapper API R, 머신 러닝 프레임워크 종류가 많았다. 파이썬 머신러닝 = Scikit-Learn 에서 쉽게 쓸 수 있도록 개발,Scikit - Learn Wraooer API Python Wrapper 방식 x_train, y_train 각 모듈에 맞도록 행렬을 재변환 해야 함. 1234567891011121314151617181920import xgboost as xgb from sklearn.model_selection import train_test_splitimport seaborn as sns # 데이터 분리titanic = sns.load_dataset('titanic')# titanic.info()# X, 독립변수, y 종속변수X = titanic[['pclass', 'parch', 'fare']]y = titanic['survived']# 훈련데이터, 테스트 데이터 분리X_train, X_test, y_train, y_test = train_test_split(X, y, stratify = y, test_size = 0.3, random_state=42)X_train.shape, X_test.shape, y_train.shape, y_test.shape ((623, 3), (268, 3), (623,), (268,)) ********# 여기가 핵심. 123dtrain = xgb.DMatrix(data=X_train,label=y_train)dtest = xgb.DMatrix(data=X_test,label=y_test)print(dtrain) &lt;xgboost.core.DMatrix object at 0x7fafd3fdf890&gt; 머신러닝 코드 123456789101112131415161718params = { 'max_depth':3, 'n_estimators' : 100, 'eta' : 0.1, 'objective' : 'binary:logistic'}num_rounds = 400w_list = [(dtrain, 'train'),(dtest,'test')]xgb_ml = xgb.train(params = params, dtrain=dtrain, num_boost_round=400, early_stopping_rounds=100, evals = w_list) [0] train-error:0.260032 test-error:0.302239 Multiple eval metrics have been passed: 'test-error' will be used for early stopping. Will train until test-error hasn't improved in 100 rounds. [1] train-error:0.260032 test-error:0.302239 [2] train-error:0.260032 test-error:0.302239 [3] train-error:0.260032 test-error:0.302239 [4] train-error:0.260032 test-error:0.302239 [5] train-error:0.260032 test-error:0.302239 [6] train-error:0.260032 test-error:0.302239 [7] train-error:0.260032 test-error:0.302239 [8] train-error:0.260032 test-error:0.302239 [9] train-error:0.260032 test-error:0.302239 [10] train-error:0.260032 test-error:0.302239 [11] train-error:0.260032 test-error:0.302239 [12] train-error:0.260032 test-error:0.302239 [13] train-error:0.247191 test-error:0.298507 [14] train-error:0.247191 test-error:0.298507 [15] train-error:0.248796 test-error:0.302239 [16] train-error:0.248796 test-error:0.302239 [17] train-error:0.248796 test-error:0.302239 [18] train-error:0.248796 test-error:0.302239 [19] train-error:0.248796 test-error:0.302239 [20] train-error:0.248796 test-error:0.302239 [21] train-error:0.248796 test-error:0.302239 [22] train-error:0.248796 test-error:0.302239 [23] train-error:0.248796 test-error:0.302239 [24] train-error:0.248796 test-error:0.302239 [25] train-error:0.248796 test-error:0.302239 [26] train-error:0.248796 test-error:0.302239 [27] train-error:0.248796 test-error:0.302239 [28] train-error:0.247191 test-error:0.302239 [29] train-error:0.247191 test-error:0.302239 [30] train-error:0.247191 test-error:0.302239 [31] train-error:0.243981 test-error:0.298507 [32] train-error:0.247191 test-error:0.302239 [33] train-error:0.243981 test-error:0.298507 [34] train-error:0.243981 test-error:0.298507 [35] train-error:0.242376 test-error:0.294776 [36] train-error:0.24077 test-error:0.294776 [37] train-error:0.24077 test-error:0.294776 [38] train-error:0.24077 test-error:0.294776 [39] train-error:0.24077 test-error:0.294776 [40] train-error:0.24077 test-error:0.294776 [41] train-error:0.24077 test-error:0.294776 [42] train-error:0.24077 test-error:0.294776 [43] train-error:0.24077 test-error:0.294776 [44] train-error:0.24077 test-error:0.302239 [45] train-error:0.24077 test-error:0.302239 [46] train-error:0.24077 test-error:0.302239 [47] train-error:0.24077 test-error:0.302239 [48] train-error:0.24077 test-error:0.302239 [49] train-error:0.24077 test-error:0.302239 [50] train-error:0.24077 test-error:0.302239 [51] train-error:0.24077 test-error:0.302239 [52] train-error:0.23435 test-error:0.302239 [53] train-error:0.23435 test-error:0.302239 [54] train-error:0.232745 test-error:0.298507 [55] train-error:0.229535 test-error:0.298507 [56] train-error:0.229535 test-error:0.298507 [57] train-error:0.229535 test-error:0.298507 [58] train-error:0.229535 test-error:0.298507 [59] train-error:0.227929 test-error:0.294776 [60] train-error:0.227929 test-error:0.298507 [61] train-error:0.227929 test-error:0.298507 [62] train-error:0.227929 test-error:0.298507 [63] train-error:0.227929 test-error:0.298507 [64] train-error:0.227929 test-error:0.298507 [65] train-error:0.227929 test-error:0.298507 [66] train-error:0.227929 test-error:0.298507 [67] train-error:0.227929 test-error:0.298507 [68] train-error:0.227929 test-error:0.298507 [69] train-error:0.227929 test-error:0.298507 [70] train-error:0.227929 test-error:0.298507 [71] train-error:0.227929 test-error:0.298507 [72] train-error:0.227929 test-error:0.302239 [73] train-error:0.227929 test-error:0.302239 [74] train-error:0.229535 test-error:0.30597 [75] train-error:0.229535 test-error:0.30597 [76] train-error:0.229535 test-error:0.30597 [77] train-error:0.229535 test-error:0.30597 [78] train-error:0.229535 test-error:0.30597 [79] train-error:0.229535 test-error:0.30597 [80] train-error:0.229535 test-error:0.30597 [81] train-error:0.229535 test-error:0.30597 [82] train-error:0.229535 test-error:0.30597 [83] train-error:0.229535 test-error:0.30597 [84] train-error:0.229535 test-error:0.30597 [85] train-error:0.229535 test-error:0.30597 [86] train-error:0.229535 test-error:0.30597 [87] train-error:0.229535 test-error:0.30597 [88] train-error:0.229535 test-error:0.30597 [89] train-error:0.229535 test-error:0.30597 [90] train-error:0.229535 test-error:0.30597 [91] train-error:0.229535 test-error:0.30597 [92] train-error:0.229535 test-error:0.30597 [93] train-error:0.229535 test-error:0.30597 [94] train-error:0.227929 test-error:0.313433 [95] train-error:0.226324 test-error:0.313433 [96] train-error:0.223114 test-error:0.317164 [97] train-error:0.223114 test-error:0.317164 [98] train-error:0.223114 test-error:0.317164 [99] train-error:0.223114 test-error:0.317164 [100] train-error:0.223114 test-error:0.317164 [101] train-error:0.223114 test-error:0.317164 [102] train-error:0.223114 test-error:0.317164 [103] train-error:0.223114 test-error:0.317164 [104] train-error:0.223114 test-error:0.317164 [105] train-error:0.223114 test-error:0.317164 [106] train-error:0.223114 test-error:0.317164 [107] train-error:0.223114 test-error:0.317164 [108] train-error:0.223114 test-error:0.317164 [109] train-error:0.223114 test-error:0.317164 [110] train-error:0.223114 test-error:0.317164 [111] train-error:0.223114 test-error:0.317164 [112] train-error:0.223114 test-error:0.317164 [113] train-error:0.223114 test-error:0.317164 [114] train-error:0.223114 test-error:0.317164 [115] train-error:0.223114 test-error:0.317164 [116] train-error:0.223114 test-error:0.317164 [117] train-error:0.223114 test-error:0.317164 [118] train-error:0.223114 test-error:0.317164 [119] train-error:0.223114 test-error:0.317164 [120] train-error:0.223114 test-error:0.317164 [121] train-error:0.223114 test-error:0.317164 [122] train-error:0.223114 test-error:0.317164 [123] train-error:0.223114 test-error:0.317164 [124] train-error:0.224719 test-error:0.317164 [125] train-error:0.224719 test-error:0.317164 [126] train-error:0.224719 test-error:0.317164 [127] train-error:0.221509 test-error:0.317164 [128] train-error:0.223114 test-error:0.317164 [129] train-error:0.219904 test-error:0.313433 [130] train-error:0.215088 test-error:0.313433 [131] train-error:0.215088 test-error:0.313433 [132] train-error:0.215088 test-error:0.313433 [133] train-error:0.215088 test-error:0.313433 [134] train-error:0.215088 test-error:0.313433 [135] train-error:0.215088 test-error:0.313433 Stopping. Best iteration: [35] train-error:0.242376 test-error:0.294776 123456# 이제 평가를 하자.from sklearn.metrics import accuracy_scorepred_probs = xgb_ml.predict(dtest)y_pred = [1 if x&gt;0.5 else 0 for x in pred_probs]# 예측 라벨과 실제 라벨 사이의 정확도 측정accuracy_score(y_pred, y_test) 0.6865671641791045 Scikit-Learn API 방식1234567891011121314151617181920from sklearn.tree import DecisionTreeClassifierfrom xgboost import XGBClassifier # API # dt = DecisionTreeClassifier()xgb_model = XGBClassifier(objective = 'binary:logistic', n_estimators=100, max_depth=3, learning_rate = 0.1, num_rounds = 400, random_state=42)w_list = [(X_train, y_train), (X_test, y_test)]xgb_model.fit(X_train, y_train, eval_set = w_list, eval_metric='error', verbose=True)y_probas = xgb_model.predict_proba(X_test)y_pred = [1 if x &gt; 0.5 else 0 for x in pred_probs]# 예측 라벨과 실제 라벨 사이의 정확도 측정accuracy_score(y_pred, y_test) [0] validation_0-error:0.260032 validation_1-error:0.302239 [1] validation_0-error:0.260032 validation_1-error:0.302239 [2] validation_0-error:0.260032 validation_1-error:0.302239 [3] validation_0-error:0.260032 validation_1-error:0.302239 [4] validation_0-error:0.260032 validation_1-error:0.302239 [5] validation_0-error:0.260032 validation_1-error:0.302239 [6] validation_0-error:0.260032 validation_1-error:0.302239 [7] validation_0-error:0.260032 validation_1-error:0.302239 [8] validation_0-error:0.260032 validation_1-error:0.302239 [9] validation_0-error:0.260032 validation_1-error:0.302239 [10] validation_0-error:0.260032 validation_1-error:0.302239 [11] validation_0-error:0.260032 validation_1-error:0.302239 [12] validation_0-error:0.260032 validation_1-error:0.302239 [13] validation_0-error:0.247191 validation_1-error:0.298507 [14] validation_0-error:0.247191 validation_1-error:0.298507 [15] validation_0-error:0.248796 validation_1-error:0.302239 [16] validation_0-error:0.248796 validation_1-error:0.302239 [17] validation_0-error:0.248796 validation_1-error:0.302239 [18] validation_0-error:0.248796 validation_1-error:0.302239 [19] validation_0-error:0.248796 validation_1-error:0.302239 [20] validation_0-error:0.248796 validation_1-error:0.302239 [21] validation_0-error:0.248796 validation_1-error:0.302239 [22] validation_0-error:0.248796 validation_1-error:0.302239 [23] validation_0-error:0.248796 validation_1-error:0.302239 [24] validation_0-error:0.248796 validation_1-error:0.302239 [25] validation_0-error:0.248796 validation_1-error:0.302239 [26] validation_0-error:0.248796 validation_1-error:0.302239 [27] validation_0-error:0.248796 validation_1-error:0.302239 [28] validation_0-error:0.247191 validation_1-error:0.302239 [29] validation_0-error:0.247191 validation_1-error:0.302239 [30] validation_0-error:0.247191 validation_1-error:0.302239 [31] validation_0-error:0.243981 validation_1-error:0.298507 [32] validation_0-error:0.247191 validation_1-error:0.302239 [33] validation_0-error:0.243981 validation_1-error:0.298507 [34] validation_0-error:0.243981 validation_1-error:0.298507 [35] validation_0-error:0.242376 validation_1-error:0.294776 [36] validation_0-error:0.24077 validation_1-error:0.294776 [37] validation_0-error:0.24077 validation_1-error:0.294776 [38] validation_0-error:0.24077 validation_1-error:0.294776 [39] validation_0-error:0.24077 validation_1-error:0.294776 [40] validation_0-error:0.24077 validation_1-error:0.294776 [41] validation_0-error:0.24077 validation_1-error:0.294776 [42] validation_0-error:0.24077 validation_1-error:0.294776 [43] validation_0-error:0.24077 validation_1-error:0.294776 [44] validation_0-error:0.24077 validation_1-error:0.302239 [45] validation_0-error:0.24077 validation_1-error:0.302239 [46] validation_0-error:0.24077 validation_1-error:0.302239 [47] validation_0-error:0.24077 validation_1-error:0.302239 [48] validation_0-error:0.24077 validation_1-error:0.302239 [49] validation_0-error:0.24077 validation_1-error:0.302239 [50] validation_0-error:0.24077 validation_1-error:0.302239 [51] validation_0-error:0.24077 validation_1-error:0.302239 [52] validation_0-error:0.23435 validation_1-error:0.302239 [53] validation_0-error:0.23435 validation_1-error:0.302239 [54] validation_0-error:0.232745 validation_1-error:0.298507 [55] validation_0-error:0.229535 validation_1-error:0.298507 [56] validation_0-error:0.229535 validation_1-error:0.298507 [57] validation_0-error:0.229535 validation_1-error:0.298507 [58] validation_0-error:0.229535 validation_1-error:0.298507 [59] validation_0-error:0.227929 validation_1-error:0.294776 [60] validation_0-error:0.227929 validation_1-error:0.298507 [61] validation_0-error:0.227929 validation_1-error:0.298507 [62] validation_0-error:0.227929 validation_1-error:0.298507 [63] validation_0-error:0.227929 validation_1-error:0.298507 [64] validation_0-error:0.227929 validation_1-error:0.298507 [65] validation_0-error:0.227929 validation_1-error:0.298507 [66] validation_0-error:0.227929 validation_1-error:0.298507 [67] validation_0-error:0.227929 validation_1-error:0.298507 [68] validation_0-error:0.227929 validation_1-error:0.298507 [69] validation_0-error:0.227929 validation_1-error:0.298507 [70] validation_0-error:0.227929 validation_1-error:0.298507 [71] validation_0-error:0.227929 validation_1-error:0.298507 [72] validation_0-error:0.227929 validation_1-error:0.302239 [73] validation_0-error:0.227929 validation_1-error:0.302239 [74] validation_0-error:0.229535 validation_1-error:0.30597 [75] validation_0-error:0.229535 validation_1-error:0.30597 [76] validation_0-error:0.229535 validation_1-error:0.30597 [77] validation_0-error:0.229535 validation_1-error:0.30597 [78] validation_0-error:0.229535 validation_1-error:0.30597 [79] validation_0-error:0.229535 validation_1-error:0.30597 [80] validation_0-error:0.229535 validation_1-error:0.30597 [81] validation_0-error:0.229535 validation_1-error:0.30597 [82] validation_0-error:0.229535 validation_1-error:0.30597 [83] validation_0-error:0.229535 validation_1-error:0.30597 [84] validation_0-error:0.229535 validation_1-error:0.30597 [85] validation_0-error:0.229535 validation_1-error:0.30597 [86] validation_0-error:0.229535 validation_1-error:0.30597 [87] validation_0-error:0.229535 validation_1-error:0.30597 [88] validation_0-error:0.229535 validation_1-error:0.30597 [89] validation_0-error:0.229535 validation_1-error:0.30597 [90] validation_0-error:0.229535 validation_1-error:0.30597 [91] validation_0-error:0.229535 validation_1-error:0.30597 [92] validation_0-error:0.229535 validation_1-error:0.30597 [93] validation_0-error:0.229535 validation_1-error:0.30597 [94] validation_0-error:0.227929 validation_1-error:0.313433 [95] validation_0-error:0.226324 validation_1-error:0.313433 [96] validation_0-error:0.223114 validation_1-error:0.317164 [97] validation_0-error:0.223114 validation_1-error:0.317164 [98] validation_0-error:0.223114 validation_1-error:0.317164 [99] validation_0-error:0.223114 validation_1-error:0.317164 0.6865671641791045 LightGBM Pthon Wrapper 방식123456789101112131415161718192021222324252627282930313233343536import lightgbm as lgb from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_scoreimport seaborn as sns # tips 데이터셋 titanic = sns.load_dataset('titanic')X = titanic[['pclass', 'parch', 'fare']]y = titanic['survived']# 훈련데이터, 테스트 데이터 분리X_train, X_test, y_train, y_test = train_test_split(X, y, stratify = y, test_size = 0.3, random_state=42)# XGBoost 코드와 유사하다. dtrain = lgb.Dataset(data = X_train, label = y_train)dtest = lgb.Dataset(data = X_test, label = y_test)params = {'max_depth':3, 'n_estimators':100, 'learning_rate': 0.1, 'objective':'binary', 'metric' : 'binary_error', 'num_boost_round' : 400, 'verbose' : 1} w_list = [dtrain, dtest]lgb_ml = lgb.train(params=params, train_set = dtrain,\\ early_stopping_rounds=100, valid_sets= w_list)pred_probs = lgb_ml.predict(X_test)y_pred=[1 if x &gt; 0.5 else 0 for x in pred_probs]# 예측 라벨과 실제 라벨 사이의 정확도 측정accuracy_score(y_pred, y_test) /usr/local/lib/python3.7/dist-packages/lightgbm/engine.py:118: UserWarning: Found `num_boost_round` in params. Will use it instead of argument warnings.warn(&quot;Found `{}` in params. Will use it instead of argument&quot;.format(alias)) [1] training's binary_error: 0.383628 valid_1's binary_error: 0.384328 Training until validation scores don't improve for 100 rounds. [2] training's binary_error: 0.383628 valid_1's binary_error: 0.384328 [3] training's binary_error: 0.354735 valid_1's binary_error: 0.369403 [4] training's binary_error: 0.29695 valid_1's binary_error: 0.354478 [5] training's binary_error: 0.272873 valid_1's binary_error: 0.33209 [6] training's binary_error: 0.272873 valid_1's binary_error: 0.33209 [7] training's binary_error: 0.269663 valid_1's binary_error: 0.317164 [8] training's binary_error: 0.269663 valid_1's binary_error: 0.317164 [9] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [10] training's binary_error: 0.269663 valid_1's binary_error: 0.309701 [11] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [12] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [13] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [14] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [15] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [16] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [17] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [18] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [19] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [20] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [21] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [22] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [23] training's binary_error: 0.271268 valid_1's binary_error: 0.313433 [24] training's binary_error: 0.258427 valid_1's binary_error: 0.309701 [25] training's binary_error: 0.258427 valid_1's binary_error: 0.309701 [26] training's binary_error: 0.258427 valid_1's binary_error: 0.309701 [27] training's binary_error: 0.258427 valid_1's binary_error: 0.309701 [28] training's binary_error: 0.258427 valid_1's binary_error: 0.309701 [29] training's binary_error: 0.255217 valid_1's binary_error: 0.309701 [30] training's binary_error: 0.255217 valid_1's binary_error: 0.309701 [31] training's binary_error: 0.255217 valid_1's binary_error: 0.309701 [32] training's binary_error: 0.255217 valid_1's binary_error: 0.309701 [33] training's binary_error: 0.255217 valid_1's binary_error: 0.317164 [34] training's binary_error: 0.255217 valid_1's binary_error: 0.317164 [35] training's binary_error: 0.255217 valid_1's binary_error: 0.317164 [36] training's binary_error: 0.255217 valid_1's binary_error: 0.309701 [37] training's binary_error: 0.255217 valid_1's binary_error: 0.317164 [38] training's binary_error: 0.255217 valid_1's binary_error: 0.317164 [39] training's binary_error: 0.248796 valid_1's binary_error: 0.309701 [40] training's binary_error: 0.248796 valid_1's binary_error: 0.313433 [41] training's binary_error: 0.248796 valid_1's binary_error: 0.313433 [42] training's binary_error: 0.248796 valid_1's binary_error: 0.313433 [43] training's binary_error: 0.248796 valid_1's binary_error: 0.313433 [44] training's binary_error: 0.248796 valid_1's binary_error: 0.313433 [45] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [46] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [47] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [48] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [49] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [50] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [51] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [52] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [53] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [54] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [55] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [56] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [57] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [58] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [59] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [60] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [61] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [62] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [63] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [64] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [65] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [66] training's binary_error: 0.243981 valid_1's binary_error: 0.309701 [67] training's binary_error: 0.23435 valid_1's binary_error: 0.309701 [68] training's binary_error: 0.23435 valid_1's binary_error: 0.309701 [69] training's binary_error: 0.23435 valid_1's binary_error: 0.309701 [70] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [71] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [72] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [73] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [74] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [75] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [76] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [77] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [78] training's binary_error: 0.232745 valid_1's binary_error: 0.313433 [79] training's binary_error: 0.232745 valid_1's binary_error: 0.313433 [80] training's binary_error: 0.232745 valid_1's binary_error: 0.313433 [81] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [82] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [83] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [84] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [85] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [86] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [87] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [88] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [89] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [90] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [91] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [92] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [93] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [94] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [95] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [96] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [97] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [98] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [99] training's binary_error: 0.221509 valid_1's binary_error: 0.317164 [100] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [101] training's binary_error: 0.23114 valid_1's binary_error: 0.30597 [102] training's binary_error: 0.23114 valid_1's binary_error: 0.30597 [103] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [104] training's binary_error: 0.221509 valid_1's binary_error: 0.317164 [105] training's binary_error: 0.221509 valid_1's binary_error: 0.317164 [106] training's binary_error: 0.224719 valid_1's binary_error: 0.313433 [107] training's binary_error: 0.224719 valid_1's binary_error: 0.317164 [108] training's binary_error: 0.224719 valid_1's binary_error: 0.317164 [109] training's binary_error: 0.224719 valid_1's binary_error: 0.317164 [110] training's binary_error: 0.224719 valid_1's binary_error: 0.317164 [111] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [112] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [113] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [114] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [115] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [116] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [117] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [118] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [119] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [120] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [121] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [122] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [123] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [124] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [125] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [126] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [127] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [128] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [129] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [130] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [131] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [132] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [133] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [134] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [135] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [136] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [137] training's binary_error: 0.219904 valid_1's binary_error: 0.309701 [138] training's binary_error: 0.219904 valid_1's binary_error: 0.309701 [139] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [140] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [141] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [142] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [143] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [144] training's binary_error: 0.221509 valid_1's binary_error: 0.320896 [145] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [146] training's binary_error: 0.221509 valid_1's binary_error: 0.313433 [147] training's binary_error: 0.221509 valid_1's binary_error: 0.313433 [148] training's binary_error: 0.221509 valid_1's binary_error: 0.313433 [149] training's binary_error: 0.221509 valid_1's binary_error: 0.313433 [150] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [151] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [152] training's binary_error: 0.221509 valid_1's binary_error: 0.313433 [153] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [154] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [155] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [156] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [157] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [158] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [159] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [160] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [161] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [162] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [163] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [164] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [165] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [166] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [167] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [168] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [169] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [170] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [171] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [172] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [173] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [174] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [175] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [176] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [177] training's binary_error: 0.221509 valid_1's binary_error: 0.328358 [178] training's binary_error: 0.221509 valid_1's binary_error: 0.328358 [179] training's binary_error: 0.221509 valid_1's binary_error: 0.328358 [180] training's binary_error: 0.221509 valid_1's binary_error: 0.328358 [181] training's binary_error: 0.221509 valid_1's binary_error: 0.328358 [182] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [183] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [184] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [185] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [186] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [187] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [188] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [189] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [190] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [191] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [192] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [193] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [194] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [195] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [196] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [197] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [198] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [199] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [200] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [201] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 Early stopping, best iteration is: [101] training's binary_error: 0.23114 valid_1's binary_error: 0.30597 0.6940298507462687 LightGBM Scikit-Learn API 방식12345678910111213141516171819202122from lightgbm import LGBMClassifierfrom sklearn.metrics import accuracy_score# model w_list = [dtrain, dtest]model = LGBMClassifier(objective = 'binary', metric = 'binary_error', n_estimators=100, learning_rate=0.1, max_depth=3, num_boost_round = 400, random_state = 32)model.fit(X_train, y_train, eval_set = [(X_train, y_train), (X_test, y_test)], verbose=1, early_stopping_rounds = 100)y_probas = model.predict_proba(X_test) y_pred=[1 if x &gt; 0.5 else 0 for x in y_probas[:, 1]] # 예측 라벨(0과 1로 예측)# 예측 라벨과 실제 라벨 사이의 정확도 측정accuracy_score(y_pred, y_test) [1] training's binary_error: 0.383628 valid_1's binary_error: 0.384328 Training until validation scores don't improve for 100 rounds. [2] training's binary_error: 0.383628 valid_1's binary_error: 0.384328 [3] training's binary_error: 0.354735 valid_1's binary_error: 0.369403 [4] training's binary_error: 0.29695 valid_1's binary_error: 0.354478 [5] training's binary_error: 0.272873 valid_1's binary_error: 0.33209 [6] training's binary_error: 0.272873 valid_1's binary_error: 0.33209 [7] training's binary_error: 0.269663 valid_1's binary_error: 0.317164 [8] training's binary_error: 0.269663 valid_1's binary_error: 0.317164 [9] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [10] training's binary_error: 0.269663 valid_1's binary_error: 0.309701 [11] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [12] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [13] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [14] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [15] training's binary_error: 0.264848 valid_1's binary_error: 0.309701 [16] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [17] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [18] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [19] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [20] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [21] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [22] training's binary_error: 0.266453 valid_1's binary_error: 0.313433 [23] training's binary_error: 0.271268 valid_1's binary_error: 0.313433 [24] training's binary_error: 0.258427 valid_1's binary_error: 0.309701 [25] training's binary_error: 0.258427 valid_1's binary_error: 0.309701 [26] training's binary_error: 0.258427 valid_1's binary_error: 0.309701 [27] training's binary_error: 0.258427 valid_1's binary_error: 0.309701 [28] training's binary_error: 0.258427 valid_1's binary_error: 0.309701 [29] training's binary_error: 0.255217 valid_1's binary_error: 0.309701 [30] training's binary_error: 0.255217 valid_1's binary_error: 0.309701 [31] training's binary_error: 0.255217 valid_1's binary_error: 0.309701 [32] training's binary_error: 0.255217 valid_1's binary_error: 0.309701 [33] training's binary_error: 0.255217 valid_1's binary_error: 0.317164 [34] training's binary_error: 0.255217 valid_1's binary_error: 0.317164 [35] training's binary_error: 0.255217 valid_1's binary_error: 0.317164 [36] training's binary_error: 0.255217 valid_1's binary_error: 0.309701 [37] training's binary_error: 0.255217 valid_1's binary_error: 0.317164 [38] training's binary_error: 0.255217 valid_1's binary_error: 0.317164 [39] training's binary_error: 0.248796 valid_1's binary_error: 0.309701 [40] training's binary_error: 0.248796 valid_1's binary_error: 0.313433 [41] training's binary_error: 0.248796 valid_1's binary_error: 0.313433 [42] training's binary_error: 0.248796 valid_1's binary_error: 0.313433 [43] training's binary_error: 0.248796 valid_1's binary_error: 0.313433 [44] training's binary_error: 0.248796 valid_1's binary_error: 0.313433 [45] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [46] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [47] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [48] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [49] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [50] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [51] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [52] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [53] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [54] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [55] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [56] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [57] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [58] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [59] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [60] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [61] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [62] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [63] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [64] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [65] training's binary_error: 0.247191 valid_1's binary_error: 0.313433 [66] training's binary_error: 0.243981 valid_1's binary_error: 0.309701 [67] training's binary_error: 0.23435 valid_1's binary_error: 0.309701 [68] training's binary_error: 0.23435 valid_1's binary_error: 0.309701 [69] training's binary_error: 0.23435 valid_1's binary_error: 0.309701 [70] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [71] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [72] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [73] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [74] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [75] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [76] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [77] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [78] training's binary_error: 0.232745 valid_1's binary_error: 0.313433 [79] training's binary_error: 0.232745 valid_1's binary_error: 0.313433 [80] training's binary_error: 0.232745 valid_1's binary_error: 0.313433 [81] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [82] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [83] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [84] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [85] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [86] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [87] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [88] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [89] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [90] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [91] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [92] training's binary_error: 0.229535 valid_1's binary_error: 0.309701 [93] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [94] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [95] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [96] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [97] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [98] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [99] training's binary_error: 0.221509 valid_1's binary_error: 0.317164 [100] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [101] training's binary_error: 0.23114 valid_1's binary_error: 0.30597 [102] training's binary_error: 0.23114 valid_1's binary_error: 0.30597 [103] training's binary_error: 0.227929 valid_1's binary_error: 0.309701 [104] training's binary_error: 0.221509 valid_1's binary_error: 0.317164 [105] training's binary_error: 0.221509 valid_1's binary_error: 0.317164 [106] training's binary_error: 0.224719 valid_1's binary_error: 0.313433 [107] training's binary_error: 0.224719 valid_1's binary_error: 0.317164 [108] training's binary_error: 0.224719 valid_1's binary_error: 0.317164 [109] training's binary_error: 0.224719 valid_1's binary_error: 0.317164 [110] training's binary_error: 0.224719 valid_1's binary_error: 0.317164 [111] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [112] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [113] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [114] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [115] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [116] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [117] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [118] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [119] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [120] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [121] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [122] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [123] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [124] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [125] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [126] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [127] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [128] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [129] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [130] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [131] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [132] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [133] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [134] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [135] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [136] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [137] training's binary_error: 0.219904 valid_1's binary_error: 0.309701 [138] training's binary_error: 0.219904 valid_1's binary_error: 0.309701 [139] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [140] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [141] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [142] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [143] training's binary_error: 0.223114 valid_1's binary_error: 0.309701 [144] training's binary_error: 0.221509 valid_1's binary_error: 0.320896 [145] training's binary_error: 0.223114 valid_1's binary_error: 0.313433 [146] training's binary_error: 0.221509 valid_1's binary_error: 0.313433 [147] training's binary_error: 0.221509 valid_1's binary_error: 0.313433 [148] training's binary_error: 0.221509 valid_1's binary_error: 0.313433 [149] training's binary_error: 0.221509 valid_1's binary_error: 0.313433 [150] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [151] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [152] training's binary_error: 0.221509 valid_1's binary_error: 0.313433 [153] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [154] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [155] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [156] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [157] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [158] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [159] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [160] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [161] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [162] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [163] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [164] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [165] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [166] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [167] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [168] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [169] training's binary_error: 0.219904 valid_1's binary_error: 0.324627 [170] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [171] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [172] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [173] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [174] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [175] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [176] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [177] training's binary_error: 0.221509 valid_1's binary_error: 0.328358 [178] training's binary_error: 0.221509 valid_1's binary_error: 0.328358 [179] training's binary_error: 0.221509 valid_1's binary_error: 0.328358 [180] training's binary_error: 0.221509 valid_1's binary_error: 0.328358 [181] training's binary_error: 0.221509 valid_1's binary_error: 0.328358 [182] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [183] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [184] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [185] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [186] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [187] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [188] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [189] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [190] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [191] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [192] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [193] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [194] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [195] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [196] training's binary_error: 0.216693 valid_1's binary_error: 0.320896 [197] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [198] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [199] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [200] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 [201] training's binary_error: 0.215088 valid_1's binary_error: 0.317164 Early stopping, best iteration is: [101] training's binary_error: 0.23114 valid_1's binary_error: 0.30597 /usr/local/lib/python3.7/dist-packages/lightgbm/engine.py:118: UserWarning: Found `num_boost_round` in params. Will use it instead of argument warnings.warn(&quot;Found `{}` in params. Will use it instead of argument&quot;.format(alias)) 0.6940298507462687","link":"/2022/07/06/day0706_ml_ch07_etc/"}],"tags":[],"categories":[]}